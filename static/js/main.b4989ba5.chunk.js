(this.webpackJsonpweb3playground=this.webpackJsonpweb3playground||[]).push([[1],{100:function(n,e,r){"use strict";r.d(e,"e",(function(){return f})),r.d(e,"d",(function(){return y})),r.d(e,"c",(function(){return h})),r.d(e,"b",(function(){return B})),r.d(e,"a",(function(){return O})),r.d(e,"f",(function(){return N}));var t,a,i=r(33),o=r.n(i),s=r(69),c=r(68),l=r(14),u=r(259),d=r.n(u),g=r(72),m={ETHEREUM_MAINNET:{value:"mainnet",label:"Ethereum Mainnet",id:1},ETHEREUM_ROPSTEN:{value:"ropsten",label:"Ropsten Testnet",id:3},ETHEREUM_RINKEBY:{value:"rinkeby",label:"Rinkeby Testnet",id:4},ETHEREUM_GOERLI:{value:"goerli",label:"Goerli Testnet",id:5},ETHEREUM_KOVAN:{value:"kovan",label:"Kovan Testnet",id:42},BSC_MAINNET:{value:"bsc",label:"Binance Smart Chain Mainnet",id:56},BSC_TESTNET:{value:"bsc-testnet",label:"Binance Smart Chain Testnet",id:97},MATIC_MAINNET:{value:"matic",label:"Matic Mainnet",id:137},MATIC_MUMBAI:{value:"mumbai",label:"Matic Mumbai",id:80001}},b=window.ethereum;function p(){return _.apply(this,arguments)}function _(){return(_=Object(c.a)(o.a.mark((function n(){return o.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(!t||!a){n.next=2;break}return n.abrupt("return",t);case 2:if(!b){n.next=13;break}if(b.autoRefreshOnNetworkChange=!1,!b.enable){n.next=7;break}return n.next=7,b.enable();case 7:return t=new d.a(b),n.next=10,t.eth.net.getId();case 10:a=n.sent,n.next=15;break;case 13:a=0,t=new d.a(new d.a.providers.HttpProvider("https://localhost:8545"));case 15:return n.abrupt("return",t);case 16:case"end":return n.stop()}}),n)})))).apply(this,arguments)}function f(){return v.apply(this,arguments)}function v(){return(v=Object(c.a)(o.a.mark((function n(){return o.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.abrupt("return",p());case 1:case"end":return n.stop()}}),n)})))).apply(this,arguments)}function y(n){var e=Object.values(m).find((function(e){return Number(e.id)===Number(n)}));return e?e.value:"unknown"}function h(){return a}function E(){return a===m.ETHEREUM_MAINNET.id||a===m.ETHEREUM_ROPSTEN.id||a===m.ETHEREUM_KOVAN.id||a===m.ETHEREUM_GOERLI.id||a===m.ETHEREUM_RINKEBY.id}function P(){return a===m.MATIC_MAINNET.id||a===m.MATIC_MUMBAI.id}function k(){return a===m.BSC_MAINNET.id||a===m.BSC_TESTNET.id}function B(){return E()?"39MIMBN2J9SFTJW1RKQPYJI89BAPZEVJVD":k()?"XUB8PMY81UWB8TFVIN8A36SZUG1Q7H4ZD5":P()?"":(console.warn("Could not find any API Key for the chain: ".concat(a)),"")}function O(){if(E()){var n=y(a);return"https://api".concat("mainnet"!==n?"-".concat(n):"",".etherscan.io/api")}return k()?"https://api".concat(a===m.BSC_TESTNET.id?"-testnet":"",".bscscan.com/api"):P()?"https://api".concat(a===m.MATIC_MUMBAI.id?"-testnet":"",".polygonscan.com/api"):(console.warn("Could not find any API for the chain: ".concat(a)),"")}function N(){var n=Object(l.useState)(a?y(a):""),e=Object(s.a)(n,2),r=e[0],t=e[1];return Object(l.useEffect)((function(){function n(n){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];a=n,t(y(n)),e&&Object(g.m)(n)}return b&&(b.on("chainChanged",(function(){return n})),b.on("networkChanged",n),f().then((function(){return n(a,!1)}))),function(){b&&(b.off("chainChanged",n),b.off("networkChanged",n))}}),[]),r}},157:function(n,e,r){"use strict";r.d(e,"c",(function(){return b})),r.d(e,"a",(function(){return _})),r.d(e,"b",(function(){return y})),r.d(e,"d",(function(){return T}));var t=r(33),a=r.n(t),i=r(68),o=r(173),s=r.n(o),c=r(100),l=r(92),u="0x0000000000000000000000000000000000000000000000000000000000000000",d="0x0000000000000000000000000000000000000000",g=[{topic:"0xe74baeef5988edac1159d9177ca52f0f3d68f624a1996f77467eb3ebfb316537",indexed:1},{topic:"0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b",dataIndex:1},{topic:"0x4d72fe0577a3a3f7da968d7b892779dde102519c25527b29cf7054f245c791b9",indexed:2}],m=["0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3","0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc"];function b(n,e,r){return p.apply(this,arguments)}function p(){return(p=Object(i.a)(a.a.mark((function n(e,r,t){var i,o,s;return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,fetch("".concat(Object(c.a)(),"?module=contract&apikey=").concat(Object(c.b)(),"&action=getabi&address=").concat(e));case 2:return i=n.sent,n.next=5,i.json();case 5:if("Contract source code not verified"!==(o=n.sent).result){n.next=8;break}return n.abrupt("return",null);case 8:return n.next=10,_(r,o.result,t||e);case 10:return s=n.sent,n.abrupt("return",s?{contract:s,abi:o.result}:null);case 12:case"end":return n.stop()}}),n)})))).apply(this,arguments)}function _(n,e,r){switch(n){case l.a.WEB3:return function(n,e){return f.apply(this,arguments)}(e,r);case l.a.ETHERS:return function(n,e){return v.apply(this,arguments)}(e,r);default:return console.warn("Invalid Lib"),null}}function f(){return(f=Object(i.a)(a.a.mark((function n(e,r){var t;return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,Object(c.e)();case 2:return t=n.sent,n.prev=3,n.abrupt("return",new t.eth.Contract(JSON.parse(e),r));case 7:return n.prev=7,n.t0=n.catch(3),console.warn(n.t0.message),n.abrupt("return",null);case 11:case"end":return n.stop()}}),n,null,[[3,7]])})))).apply(this,arguments)}function v(){return(v=Object(i.a)(a.a.mark((function n(e,r){return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.prev=0,n.abrupt("return",new o.Contract(r,JSON.parse(e),new s.a.providers.Web3Provider(window.ethereum).getSigner()));case 4:return n.prev=4,n.t0=n.catch(0),console.warn(n.t0.message),n.abrupt("return",null);case 8:case"end":return n.stop()}}),n,null,[[0,4]])})))).apply(this,arguments)}function y(n){return h.apply(this,arguments)}function h(){return(h=Object(i.a)(a.a.mark((function n(e){var r,t,i,o,s,l,m,b,p,_,f,v,y,h,B;return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,Object(c.e)();case 2:r=n.sent,t="".concat(Object(c.a)(),"?module=logs&action=getLogs&apikey=").concat(Object(c.b)(),"&fromBlock=0&toBlock=latest&limit=1&address=").concat(e,"&topic0="),o=!0,s=!1,l=void 0,n.prev=7,m=g[Symbol.iterator]();case 9:if(o=(b=m.next()).done){n.next=34;break}return p=b.value,_=p.topic,f=p.indexed,v=p.dataIndex,n.prev=14,n.next=17,fetch("".concat(t).concat(_));case 17:return y=n.sent,n.next=20,y.json();case 20:if(!((h=n.sent).result.length>0&&"string"!==typeof h.result)){n.next=26;break}if(B=h.result.pop(),!(i=f?E(B,f):P(B,v))||"0x"===i||i===d){n.next=26;break}return n.abrupt("return",i);case 26:n.next=31;break;case 28:n.prev=28,n.t0=n.catch(14),console.warn(n.t0.messge);case 31:o=!0,n.next=9;break;case 34:n.next=40;break;case 36:n.prev=36,n.t1=n.catch(7),s=!0,l=n.t1;case 40:n.prev=40,n.prev=41,o||null==m.return||m.return();case 43:if(n.prev=43,!s){n.next=46;break}throw l;case 46:return n.finish(43);case 47:return n.finish(40);case 48:return n.next=50,k(r,e);case 50:if((i=n.sent)&&(!i||i!==u&&i!==d)){n.next=55;break}return n.next=54,O(r,e);case 54:i=n.sent;case 55:return n.abrupt("return",i);case 56:case"end":return n.stop()}}),n,null,[[7,36,40,48],[14,28],[41,,43,47]])})))).apply(this,arguments)}function E(n,e){return"0x".concat(n.topics[e].slice(-40))}function P(n,e){var r=32*(e-1)+24;return"0x".concat(n.data.slice(2).substr(r,r+40))}function k(n,e){return B.apply(this,arguments)}function B(){return(B=Object(i.a)(a.a.mark((function n(e,r){var t,i,o,s,l,u,g,b,p;return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:t=!0,i=!1,o=void 0,n.prev=3,s=m[Symbol.iterator]();case 5:if(t=(l=s.next()).done){n.next=25;break}return u=l.value,n.prev=7,n.next=10,fetch("".concat(Object(c.a)(),"?module=proxy&action=eth_getStorageAt&address=").concat(r,"&apikey=").concat(Object(c.b)(),"&position=").concat(u,"&tag=latest"));case 10:return g=n.sent,n.next=13,g.json();case 13:if(b=n.sent.result,p=void 0,b&&e.utils.isAddress(b.slice(-40))&&(p="0x".concat(b.slice(-40))),!p||"0x"===p||p===d){n.next=18;break}return n.abrupt("return",p);case 18:n.next=22;break;case 20:n.prev=20,n.t0=n.catch(7);case 22:t=!0,n.next=5;break;case 25:n.next=31;break;case 27:n.prev=27,n.t1=n.catch(3),i=!0,o=n.t1;case 31:n.prev=31,n.prev=32,t||null==s.return||s.return();case 34:if(n.prev=34,!i){n.next=37;break}throw o;case 37:return n.finish(34);case 38:return n.finish(31);case 39:case"end":return n.stop()}}),n,null,[[3,27,31,39],[7,20],[32,,34,38]])})))).apply(this,arguments)}function O(n,e){return N.apply(this,arguments)}function N(){return(N=Object(i.a)(a.a.mark((function n(e,r){var t,i,o,s,l;return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,fetch("".concat(Object(c.a)(),"?module=proxy&apikey=").concat(Object(c.b)(),"&action=eth_getCode&address=").concat(r));case 2:return t=n.sent,n.next=5,t.json();case 5:return i=n.sent.result,s=-1!==i.indexOf("0x36")?22:24,l="0x".concat(i.slice(s,s+40)),i&&e.utils.isAddress(l)&&(o=l),n.abrupt("return",o);case 10:case"end":return n.stop()}}),n)})))).apply(this,arguments)}function T(n,e,r){switch(r){case l.a.WEB3:return function(n,e){return n+Object.keys(e).filter((function(n){return e[n].instance})).map((function(n){var r=e[n].instance;return"declare var ".concat(e[n].name,": Contract & {\n  methods: {\n    ").concat(r.options.jsonInterface.map((function(n){var e="";return n.inputs&&"constructor"!==n.type?(n.inputs.forEach((function(r,t){t>0&&(e+=", "),e+=r.name?r.name:n.inputs.length>1?"".concat(r.type,"_").concat(t):r.type,-1!==r.type.indexOf("int")?e+=": number | string":e+=": string",-1!==r.type.indexOf("[]")&&(e+="[]")})),"".concat(n.name,": (").concat(e,") => any")):""})).join("\n"),"\n  }")})).join("\n")}(n,e);case l.a.ETHERS:return function(n,e){return n+Object.keys(e).filter((function(n){return e[n].instance})).map((function(n){var r=e[n].instance.interface.fragments.map((function(n){var e="";return n.inputs&&"constructor"!==n.type?(n.inputs.forEach((function(r,t){t>0&&(e+=", "),e+=r.name?r.name:n.inputs.length>1?"".concat(r.type,"_").concat(t):r.type,-1!==r.type.indexOf("int")?e+=": number | string":e+=": string",-1!==r.type.indexOf("[]")&&(e+="[]")})),"".concat(n.name,": (").concat(e,") => ").concat(n.constant?"____any":"____MethodResult")):""})).join("\n");return"declare var ".concat(e[n].name,": Contract & {\n      readonly functions: {\n        ").concat(r.replace(/____MethodResult/g,"Promise<ContractTransaction>").replace(/____any/g,"Promise<any>"),"\n      }\n      readonly callStatic: {\n        ").concat(r.replace(/____MethodResult/g,"Promise<ContractTransaction>").replace(/____any/g,"Promise<any>"),"\n      }\n      readonly estimateGas: {\n        ").concat(r.replace(/____MethodResult/g,"Promise<BigNumber>").replace(/____any/g,"Promise<BigNumber>"),"\n      }\n      readonly populateTransaction: {\n        ").concat(r.replace(/____MethodResult/g,"Promise<PopulatedTransaction>").replace(/____any/g,"Promise<PopulatedTransaction>"),"\n      }\n      readonly filters: {\n        ").concat(r.replace(/____MethodResult/g,"(...args: Array<any>) => EventFilter").replace(/____any/g,"(...args: Array<any>) => EventFilter"),"\n      }\n      ").concat(r.replace(/____MethodResult/g,"Promise<ContractTransaction>").replace(/____any/g,"Promise<any>"),"\n    }")})).join("\n")}(n,e);default:return""}}},172:function(n,e,r){"use strict";r.d(e,"b",(function(){return l})),r.d(e,"a",(function(){return u})),r.d(e,"c",(function(){return d}));var t=r(33),a=r.n(t),i=r(68),o=r(129);function s(n,e){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);e&&(t=t.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.push.apply(r,t)}return r}function c(n){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?s(Object(r),!0).forEach((function(e){Object(o.a)(n,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(r,e))}))}return n}function l(n,e){return e?Object.keys(n).filter((function(n){return n!==e})).reduce((function(e,r){return c({},e,Object(o.a)({},r,n[r]))}),{}):n}function u(n,e){return Object.keys(n).filter((function(r){return e(n[r])})).reduce((function(e,r){return c({},e,Object(o.a)({},r,n[r]))}),{})}function d(n,e){return g.apply(this,arguments)}function g(){return(g=Object(i.a)(a.a.mark((function n(e,r){return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.abrupt("return",new Promise((function(n,t){setTimeout((function(){t(new Error("timeout"))}),r),e.then(n,t)})));case 1:case"end":return n.stop()}}),n)})))).apply(this,arguments)}},181:function(n,e,r){"use strict";r.d(e,"c",(function(){return u})),r.d(e,"b",(function(){return g})),r.d(e,"a",(function(){return _}));var t=r(33),a=r.n(t),i=r(68),o=r(72),s=r(172),c="https://ipfs.io/ipfs/",l="https://gateway.pinata.cloud/ipfs/";function u(){return d.apply(this,arguments)}function d(){return(d=Object(i.a)(a.a.mark((function n(){var e,r,t,i,s;return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return"b0450654b560b1db47cb","4afc2d10236c41d02a1466c451e8fa482b00eb86a0eee317fae85cb49c2680e3","https://api.pinata.cloud/pinning/pinFileToIPFS",e={network:Object(o.f)(),contracts:Object(o.d)(),code:Object(o.c)(),library:Object(o.e)()},r=JSON.stringify(e),t=new Blob([r],{type:"application/json"}),(i=new FormData).append("file",t,"web3playground-".concat(Date.now(),".json")),n.prev=8,n.next=11,fetch("https://api.pinata.cloud/pinning/pinFileToIPFS",{method:"POST",headers:{pinata_api_key:"b0450654b560b1db47cb",pinata_secret_api_key:"4afc2d10236c41d02a1466c451e8fa482b00eb86a0eee317fae85cb49c2680e3"},body:i});case 11:return s=n.sent,n.abrupt("return",s.json());case 15:return n.prev=15,n.t0=n.catch(8),n.abrupt("return",{error:n.t0.message});case 18:case"end":return n.stop()}}),n,null,[[8,15]])})))).apply(this,arguments)}function g(n){return m.apply(this,arguments)}function m(){return(m=Object(i.a)(a.a.mark((function n(e){var r;return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.prev=0,n.next=3,b(e,l);case 3:r=n.sent,n.next=15;break;case 6:if(n.prev=6,n.t0=n.catch(0),"timeout"!==n.t0.message){n.next=14;break}return n.next=11,b(e,c);case 11:r=n.sent,n.next=15;break;case 14:throw n.t0;case 15:return n.abrupt("return",r);case 16:case"end":return n.stop()}}),n,null,[[0,6]])})))).apply(this,arguments)}function b(n,e){return p.apply(this,arguments)}function p(){return(p=Object(i.a)(a.a.mark((function n(e,r){var t;return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,Object(s.c)(fetch("".concat(r).concat(e)),3e4);case 2:return t=n.sent,n.abrupt("return",t.json());case 4:case"end":return n.stop()}}),n)})))).apply(this,arguments)}function _(n){return{name:n,id:n}}},202:function(n,e,r){"use strict";var t=r(69),a=r(14),i=r.n(a),o=Object(a.createContext)({refreshFiles:function(){}}),s=r(129),c=r(33),l=r.n(c),u=r(68),d=r(40),g=r(42),m=r(65),b=r(55),p=r(66),_=(r(384),function(n){function e(){return Object(d.a)(this,e),Object(m.a)(this,Object(b.a)(e).apply(this,arguments))}return Object(p.a)(e,n),Object(g.a)(e,[{key:"render",value:function(){return i.a.createElement("div",{className:"lds-spinner"},i.a.createElement("div",null),i.a.createElement("div",null),i.a.createElement("div",null),i.a.createElement("div",null),i.a.createElement("div",null),i.a.createElement("div",null),i.a.createElement("div",null),i.a.createElement("div",null),i.a.createElement("div",null),i.a.createElement("div",null),i.a.createElement("div",null),i.a.createElement("div",null))}}]),e}(i.a.PureComponent)),f=r(372).a,v=r(157),y=r(72),h=r(172),E=r(181),P=r(100),k=r(92);r(786);function B(n,e){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);e&&(t=t.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.push.apply(r,t)}return r}function O(n){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?B(Object(r),!0).forEach((function(e){Object(s.a)(n,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):B(Object(r)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(r,e))}))}return n}var N=function(n){var e=n.fileId,r=n.isMaximized,o=n.handleToggleMaximizeEditor,c=Object(a.useState)(0),d=Object(t.a)(c,2),g=d[0],m=d[1],b=Object(a.useState)({}),p=Object(t.a)(b,2),B=p[0],N=p[1],T=Object(a.useState)(null),x=Object(t.a)(T,2),C=x[0],w=x[1],R=Object(a.useState)(),A=Object(t.a)(R,2),S=A[0],M=A[1],I=Object(a.useState)(),D=Object(t.a)(I,2),L=D[0],U=D[1],j=Object(a.useState)(Object(y.e)()),F=Object(t.a)(j,2),K=F[0],W=F[1],H=Object(a.useRef)(!0),q=Object(P.f)(),G=!!g,J=Object(a.useCallback)((function(n){m((function(e){return n?e+1:e-1}))}),[]),z=Object(a.useCallback)(function(){var n=Object(u.a)(l.a.mark((function n(e,r){var t,a,o;return l.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(J(!0),t=null,a=null,n.prev=3,!e.isProxy){n.next=14;break}return n.next=7,Object(v.b)(e.address);case 7:if(!(o=n.sent)){n.next=12;break}return n.next=11,Object(v.c)(o,r,e.address);case 11:t=n.sent;case 12:n.next=17;break;case 14:return n.next=16,Object(v.c)(e.address,r);case 16:t=n.sent;case 17:n.next=22;break;case 19:n.prev=19,n.t0=n.catch(3),console.warn(n.t0.message);case 22:return t||(a=i.a.createElement("p",null,"No implementation found. Please contact me",i.a.createElement("a",{href:"https://twitter.com/nachomazzara",target:"_blank",rel:"noopener noreferrer"},"@nachomazzara"))),J(!1),n.abrupt("return",{instance:t,error:a});case 25:case"end":return n.stop()}}),n,null,[[3,19]])})));return function(e,r){return n.apply(this,arguments)}}(),[J]),V=Object(a.useCallback)(function(){var n=Object(u.a)(l.a.mark((function n(e,r){var t,a,i,o,s,c;return l.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:t={},a=0;case 2:if(!(a<e.length)){n.next=13;break}return i=e[a],n.next=6,z(i,r);case 6:o=n.sent,s=o.instance,c=o.error,t[i.address]=O({},i,{abi:s?s.abi:null,instance:s?s.contract:null,error:c});case 10:a++,n.next=2;break;case 13:N(t);case 14:case"end":return n.stop()}}),n)})));return function(e,r){return n.apply(this,arguments)}}(),[z]),Z=Object(a.useCallback)(function(){var n=Object(u.a)(l.a.mark((function n(e){var r,t,a,i;return l.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:J(!0),r={},n.t0=l.a.keys(B);case 3:if((n.t1=n.t0()).done){n.next=12;break}return t=n.t1.value,a=B[t],n.next=8,Object(v.a)(e,a.abi,t);case 8:i=n.sent,r[a.address]=O({},a,{instance:i,error:null}),n.next=3;break;case 12:N(r),J(!1);case 14:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}(),[B,J]),X=Object(a.useCallback)(function(){var n=Object(u.a)(l.a.mark((function n(e){var r,t;return l.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return J(!0),n.prev=1,n.next=4,Object(E.b)(e);case 4:if(r=n.sent,t=r.library||k.a.WEB3,W(t),!r.contracts){n.next=10;break}return n.next=10,V(r.contracts,t);case 10:r.network&&M(Object(P.d)(r.network)),r.code&&w(r.code),n.next=17;break;case 14:n.prev=14,n.t0=n.catch(1),U({message:n.t0.message,hash:e});case 17:J(!1);case 18:case"end":return n.stop()}}),n,null,[[1,14]])})));return function(e){return n.apply(this,arguments)}}(),[V,J]);function Y(n){for(var e=n.currentTarget.form,r={},t=0;t<e.length;t++){var a=e[t];r[a.name]=a.value}return r}function Q(n){n.preventDefault();var e=Y(n),r=B[e.address];if(r){var t=n.currentTarget.value.replace(/\s/g,""),a=null;(function(n,e){return!!Object.keys(n).find((function(r){return n[r].name===e}))})(Object(h.b)(B,r.address),t)&&(a=i.a.createElement("p",null,'Variable name "'.concat(t,'" is already in use'))),N(O({},B,Object(s.a)({},r.address,O({},r,{name:t,error:a}))))}}function $(){return($=Object(u.a)(l.a.mark((function n(e,r){var t,a,i,o;return l.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(e.preventDefault(),!e.currentTarget.value.length){n.next=13;break}return t=Y(e),B[t.address]||(t.isProxy=!1),n.next=7,z(t,K);case 7:a=n.sent,i=a.instance,o=a.error,N(O({},Object(h.b)(B,r),Object(s.a)({},t.address,O({},t,{instance:i?i.contract:null,abi:i?i.abi:[],error:o})))),n.next=14;break;case 13:N(Object(h.b)(B,r));case 14:case"end":return n.stop()}}),n)})))).apply(this,arguments)}function nn(n){return en.apply(this,arguments)}function en(){return(en=Object(u.a)(l.a.mark((function n(e){var r,t,a,i,o;return l.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return e.preventDefault(),r=Y(e),t=B[r.address],r.isProxy=!!t&&!t.isProxy,n.next=6,z(r,K);case 6:a=n.sent,i=a.instance,o=a.error,N(O({},B,Object(s.a)({},r.address,O({},r,{instance:i?i.contract:null,abi:i?i.abi:[],error:o}))));case 10:case"end":return n.stop()}}),n)})))).apply(this,arguments)}function rn(){return(rn=Object(u.a)(l.a.mark((function n(e){var r,t,a,i,o,c,u;return l.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(e.preventDefault(),(r=Y(e)).isProxy=!1,!e.currentTarget.value.length){n.next=19;break}return t=null,a=null,i=e.currentTarget.value,n.prev=7,n.next=10,Object(v.a)(K,i,r.address);case 10:t=n.sent,n.next=16;break;case 13:n.prev=13,n.t0=n.catch(7),a=n.t0.message;case 16:N(O({},B,Object(s.a)({},r.address,O({},r,{abi:i,instance:t,error:a})))),n.next=25;break;case 19:return n.next=21,z(r,K);case 21:o=n.sent,c=o.instance,u=o.error,N(O({},B,Object(s.a)({},r.address,O({},r,{instance:c?c.contract:null,abi:c?c.abi:[],error:u}))));case 25:case"end":return n.stop()}}),n,null,[[7,13]])})))).apply(this,arguments)}function tn(n){J(!0),W(n),Object(y.l)(n),Z(n),J(!1)}function an(n){var e,r,t,a;return n&&(e=n.address,r=n.name,t=n.error,a=n.abi),i.a.createElement("form",{key:e||Date.now()},i.a.createElement("div",null,i.a.createElement("input",{name:"address",type:"text",placeholder:"contract address",value:e,onChange:function(n){return function(n,e){return $.apply(this,arguments)}(n,e)}}),i.a.createElement("input",{name:"name",type:"text",placeholder:"variable name",value:r,disabled:!e,onChange:Q}),i.a.createElement("input",{name:"abi",type:"text",placeholder:"ABI (optional)",value:a?a.toString():"",onChange:function(n){return function(n){return rn.apply(this,arguments)}(n)}}),e&&i.a.createElement("i",{className:"icon trash",onClick:function(){return function(n){N(Object(h.b)(B,n))}(e)}})),i.a.createElement("div",{className:"isProxy"},i.a.createElement("input",{name:"isProxy",type:"checkbox",disabled:!e,onChange:nn,checked:!!n&&n.isProxy}),i.a.createElement("label",{htmlFor:"checkbox"},"Upgradable contract using a proxy pattern"," ",i.a.createElement("a",{target:"_blank",href:"https://github.com/nachomazzara/web3playground#which-proxy-implementations-are-supported",rel:"noopener noreferrer"},"?"))),t&&i.a.createElement("div",{className:"error"},t))}return Object(a.useEffect)((function(){if(q){var n=window.location.pathname.split("/").splice(1)[0];if(n)X(n);else{var e=Object(y.d)(),r=Object(y.f)();e&&(M(Object(P.d)(r)),V(e,K))}}}),[q,V,X]),Object(a.useEffect)((function(){e&&X(e)}),[e,X]),Object(a.useLayoutEffect)((function(){if(H.current)H.current=!1;else{var n=Object.keys(B).map((function(n){return{name:B[n].name,address:B[n].address,isProxy:B[n].isProxy}}));Object(y.k)(n)}}),[B]),i.a.createElement("div",{className:"Playground ".concat(r?" maximized":"")},G&&i.a.createElement(_,null),i.a.createElement("div",{className:"header"},i.a.createElement("div",{className:"network"},i.a.createElement("p",{className:q},q),q&&S&&q!==S&&i.a.createElement("p",{className:"error"},"The snippet you are trying to use is set to be run on ",S,". Please change the network.")),i.a.createElement("div",{className:"title"},i.a.createElement("div",null,i.a.createElement("h1",null,"".concat(K.toLowerCase()," Playground")),K!==k.a.WEB3&&i.a.createElement("button",{onClick:function(){return tn(k.a.WEB3)}},"Switch to Web3"),K!==k.a.ETHERS&&i.a.createElement("button",{onClick:function(){return tn(k.a.ETHERS)}},"Switch to Ethers")),i.a.createElement("div",{className:"menu"},i.a.createElement("a",{target:"_blank",href:"https://github.com/nachomazzara/web3playground#how-it-works",rel:"noopener noreferrer"},"How it works \ud83d\udc68\u200d\ud83d\udcbb"))),L&&i.a.createElement("p",{className:"error ipfs-error"},"Failed to load the code snippet under the hash ".concat(L.hash,": ").concat(L.message)),i.a.createElement("h2",null,"Contracts"),Object.keys(B).map((function(n){return an(B[n])})),an()),i.a.createElement(f,{contracts:Object(h.a)(B,(function(n){return!n.error})),initCode:C,isMaximized:r,onChangeSize:o,library:K,isLoading:G&&!!q}))},T=r(256),x=(r(787),[]);var C=function(n){var e=n.files,r=n.currentFile,s=n.handleFileSelected,c=Object(a.useContext)(o).refreshFiles,l=Object(a.useState)(!1),u=Object(t.a)(l,2),d=u[0],g=u[1],m=Object(a.useState)(r),b=Object(t.a)(m,2),p=b[0],_=b[1];function f(){g(!d)}return Object(a.useEffect)((function(){return function(){x.forEach((function(n){var e=n.div,r=n.func;return e.removeEventListener("contextmenu",r)}))}}),[]),i.a.createElement("div",{className:"Files"},i.a.createElement("div",{className:"files-wrapper"},e.map((function(n){return i.a.createElement("div",{key:n.id,className:"file ".concat(r&&r.id===n.id?"active":""),ref:function(e){if(e&&document.addEventListener){var r=function(e){_(n),f(),e.preventDefault()};e.addEventListener("contextmenu",r,!1),x.push({div:e,func:r})}}},i.a.createElement("button",{className:"name",onClick:function(){return function(n){s(n)}(n)}},n.name),i.a.createElement("button",{className:"close",onClick:function(){return function(n){Object(y.g)(n),c()}(n)}},"x"))}))),d&&i.a.createElement(T.a,{onClose:f,file:p}))};function w(){var n=Object(a.useState)(Object(y.b)()),e=Object(t.a)(n,2),r=e[0],s=e[1],c=Object(a.useState)(!1),l=Object(t.a)(c,2),u=l[0],d=l[1],g=Object(a.useState)(),m=Object(t.a)(g,2),b=m[0],p=m[1];var _=Object(a.useCallback)((function(n){s(Object(y.b)()),n&&p(n)}),[]);return Object(a.useEffect)((function(){var n=window.location.pathname.split("/").splice(1)[0];if(n){var e=Object(y.a)(n);p(e),Object(y.i)(e),_()}}),[_]),i.a.createElement(o.Provider,{value:{refreshFiles:_}},i.a.createElement("div",{className:"".concat(u?"maximized":"")},i.a.createElement(C,{files:r,currentFile:b,handleFileSelected:function(n){p(n)}}),i.a.createElement(N,{fileId:b?b.id:void 0,isMaximized:u,handleToggleMaximizeEditor:function(){d(!u)}})))}r.d(e,"a",(function(){return w})),r.d(e,"b",(function(){return o}))},230:function(n,e,r){"use strict";r.d(e,"b",(function(){return a})),r.d(e,"a",(function(){return i}));var t=window.onbeforeunload;function a(){window.onbeforeunload=function(){return"Are you sure you want to quit?"}}function i(){window.onbeforeunload=t}},255:function(n,e,r){"use strict";function t(){return navigator.userAgent.match(/ipad|iphone/i)}r.d(e,"a",(function(){return t}))},256:function(n,e,r){"use strict";var t=r(33),a=r.n(t),i=r(68),o=r(69),s=r(14),c=r.n(s),l=r(255),u=r(181),d=r(72);r(782);function g(n){var e=n.onClose,r=n.className,t=n.title,a=n.children;return c.a.createElement("div",{className:"Modal ".concat(r)},c.a.createElement("div",{className:"modal-wrapper"},c.a.createElement("div",{className:"modal-header"},c.a.createElement("button",{className:"close",onClick:e}),c.a.createElement("h3",null,t)),c.a.createElement("div",{className:"modal-body"},a)))}var m=r(202);r(783);var b=function(n){var e,r=Object(s.useContext)(m.b).refreshFiles,t=Object(s.useState)(!0),b=Object(o.a)(t,2),p=b[0],_=b[1],f=Object(s.useState)(null),v=Object(o.a)(f,2),y=v[0],h=v[1],E=Object(s.useState)(null),P=Object(o.a)(E,2),k=P[0],B=P[1],O=Object(s.useState)("Copy"),N=Object(o.a)(O,2),T=N[0],x=N[1],C=Object(s.useCallback)(Object(i.a)(a.a.mark((function n(){var e,t,i,o;return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return _(!0),n.next=3,Object(u.c)();case 3:e=n.sent,t=e.IpfsHash,(i=e.error)?(h(null),B(i)):(h(t),o=Object(u.a)(t),Object(d.i)(o),r(o),B(null)),_(!1);case 8:case"end":return n.stop()}}),n)}))),[r]);Object(s.useEffect)((function(){C()}),[C]);var w="".concat(window.location.origin,"/").concat(y);return c.a.createElement(g,{onClose:n.onClose,className:"UploadModal",title:"Share"},p&&c.a.createElement("p",null,"Uploading..."),y&&c.a.createElement("div",null,c.a.createElement("p",null,w),c.a.createElement("textarea",{readOnly:!0,className:"no-visible",ref:function(n){n&&(e=n)},value:w}),c.a.createElement("button",{onClick:function(){if(x("Copied"),Object(l.a)()){var n=document.createRange();n.selectNodeContents(e);var r=window.getSelection();r&&(r.removeAllRanges(),r.addRange(n)),e.setSelectionRange(0,999999)}else e.select();document.execCommand("copy"),window.setTimeout((function(){return x("Copy")}),1e3)}},T)),k&&c.a.createElement("div",null,c.a.createElement("p",{className:"error"},k),c.a.createElement("button",{onClick:C},"Try again")))},p=r(129);r(784);function _(n,e){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);e&&(t=t.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.push.apply(r,t)}return r}var f=function(n){var e=n.file,r=n.onClose,t=Object(s.useContext)(m.b).refreshFiles,a=Object(s.useState)(e.name),i=Object(o.a)(a,2),l=i[0],u=i[1],b=Object(s.useState)(null),f=Object(o.a)(b,2),v=f[0],y=f[1];return c.a.createElement(g,{onClose:r,className:"RenameModal",title:"Rename"},c.a.createElement("div",{className:"form"},c.a.createElement("input",{value:l,onChange:function(n){return u(n.target.value)}}),c.a.createElement("button",{onClick:function(){Object(d.h)(function(n){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?_(Object(r),!0).forEach((function(e){Object(p.a)(n,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):_(Object(r)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(r,e))}))}return n}({},e,{name:l})),t(),r(),y(null)}},"Submit")),v&&c.a.createElement("p",{className:"error"},v))};r.d(e,"b",(function(){return b})),r.d(e,"a",(function(){return f}))},288:function(n,e,r){"use strict";var t="// This file is based of web3.js v1.2.2\n\ntype Endianness = 'le' | 'be';\ntype IPrimeName = 'k256' | 'p224' | 'p192' | 'p25519';\n\ninterface MPrime {\n  name: string;\n  p: BN;\n  n: number;\n  k: BN;\n}\n\ninterface ReductionContext {\n  m: number;\n  prime: MPrime;\n  [key: string]: any;\n}\n\ndeclare interface BN {\n  constructor(\n    number: number | string | number[] | Uint8Array | Buffer | BN,\n    base?: number | 'hex',\n    endian?: Endianness\n  );\n  constructor(\n    number: number | string | number[] | Uint8Array | Buffer | BN,\n    endian?: Endianness\n  )\n\n  /**\n   * @description  create a reduction context\n   */\n  red(reductionContext: BN | IPrimeName): ReductionContext;\n\n  /**\n   * @description  create a reduction context  with the Montgomery trick.\n   */\n  mont(num: BN): ReductionContext;\n\n  /**\n   * @description returns true if the supplied object is a BN.js instance\n   */\n  isBN(b: any): b is BN;\n\n  /**\n   * @description returns the maximum of 2 BN instances.\n   */\n  max(left: BN, right: BN): BN;\n\n  /**\n   * @description returns the minimum of 2 BN instances.\n   */\n  min(left: BN, right: BN): BN;\n\n  /**\n   * @description  clone number\n   */\n  clone(): BN;\n\n  /**\n   * @description  convert to base-string and pad with zeroes\n   */\n  toString(base?: number | 'hex', length?: number): string;\n\n  /**\n   * @description convert to Javascript Number (limited to 53 bits)\n   */\n  toNumber(): number;\n\n  /**\n   * @description convert to JSON compatible hex string (alias of toString(16))\n   */\n  toJSON(): string;\n\n  /**\n   * @description  convert to byte Array, and optionally zero pad to length, throwing if already exceeding\n   */\n  toArray(endian?: Endianness, length?: number): number[];\n\n  /**\n   * @description convert to an instance of `type`, which must behave like an Array\n   */\n  toArrayLike(\n    ArrayType: typeof Buffer,\n    endian?: Endianness,\n    length?: number\n  ): Buffer;\n\n  toArrayLike(\n    ArrayType: any[],\n    endian?: Endianness,\n    length?: number\n  ): any[];\n\n  /**\n   * @description  convert to Node.js Buffer (if available). For compatibility with browserify and similar tools, use this instead: a.toArrayLike(Buffer, endian, length)\n   */\n  toBuffer(endian?: Endianness, length?: number): Buffer;\n\n  /**\n   * @description get number of bits occupied\n   */\n  bitLength(): number;\n\n  /**\n   * @description return number of less-significant consequent zero bits (example: 1010000 has 4 zero bits)\n   */\n  zeroBits(): number;\n\n  /**\n   * @description return number of bytes occupied\n   */\n  byteLength(): number;\n\n  /**\n   * @description  true if the number is negative\n   */\n  isNeg(): boolean;\n\n  /**\n   * @description  check if value is even\n   */\n  isEven(): boolean;\n\n  /**\n   * @description   check if value is odd\n   */\n  isOdd(): boolean;\n\n  /**\n   * @description  check if value is zero\n   */\n  isZero(): boolean;\n\n  /**\n   * @description compare numbers and return `-1 (a < b)`, `0 (a == b)`, or `1 (a > b)` depending on the comparison result\n   */\n  cmp(b: BN): -1 | 0 | 1;\n\n  /**\n   * @description compare numbers and return `-1 (a < b)`, `0 (a == b)`, or `1 (a > b)` depending on the comparison result\n   */\n  ucmp(b: BN): -1 | 0 | 1;\n\n  /**\n   * @description compare numbers and return `-1 (a < b)`, `0 (a == b)`, or `1 (a > b)` depending on the comparison result\n   */\n  cmpn(b: number): -1 | 0 | 1;\n\n  /**\n   * @description a less than b\n   */\n  lt(b: BN): boolean;\n\n  /**\n   * @description a less than b\n   */\n  ltn(b: number): boolean;\n\n  /**\n   * @description a less than or equals b\n   */\n  lte(b: BN): boolean;\n\n  /**\n   * @description a less than or equals b\n   */\n  lten(b: number): boolean;\n\n  /**\n   * @description a greater than b\n   */\n  gt(b: BN): boolean;\n\n  /**\n   * @description a greater than b\n   */\n  gtn(b: number): boolean;\n\n  /**\n   * @description a greater than or equals b\n   */\n  gte(b: BN): boolean;\n\n  /**\n   * @description a greater than or equals b\n   */\n  gten(b: number): boolean;\n\n  /**\n   * @description a equals b\n   */\n  eq(b: BN): boolean;\n\n  /**\n   * @description a equals b\n   */\n  eqn(b: number): boolean;\n\n  /**\n   * @description convert to two's complement representation, where width is bit width\n   */\n  toTwos(width: number): BN;\n\n  /**\n   * @description  convert from two's complement representation, where width is the bit width\n   */\n  fromTwos(width: number): BN;\n\n  /**\n   * @description negate sign\n   */\n  neg(): BN;\n\n  /**\n   * @description negate sign\n   */\n  ineg(): BN;\n\n  /**\n   * @description absolute value\n   */\n  abs(): BN;\n\n  /**\n   * @description absolute value\n   */\n  iabs(): BN;\n\n  /**\n   * @description addition\n   */\n  add(b: BN): BN;\n\n  /**\n   * @description  addition\n   */\n  iadd(b: BN): BN;\n\n  /**\n   * @description addition\n   */\n  addn(b: number): BN;\n\n  /**\n   * @description addition\n   */\n  iaddn(b: number): BN;\n\n  /**\n   * @description subtraction\n   */\n  sub(b: BN): BN;\n\n  /**\n   * @description subtraction\n   */\n  isub(b: BN): BN;\n\n  /**\n   * @description subtraction\n   */\n  subn(b: number): BN;\n\n  /**\n   * @description subtraction\n   */\n  isubn(b: number): BN;\n\n  /**\n   * @description multiply\n   */\n  mul(b: BN): BN;\n\n  /**\n   * @description multiply\n   */\n  imul(b: BN): BN;\n\n  /**\n   * @description multiply\n   */\n  muln(b: number): BN;\n\n  /**\n   * @description multiply\n   */\n  imuln(b: number): BN;\n\n  /**\n   * @description square\n   */\n  sqr(): BN;\n\n  /**\n   * @description square\n   */\n  isqr(): BN;\n\n  /**\n   * @description raise `a` to the power of `b`\n   */\n  pow(b: BN): BN;\n\n  /**\n   * @description divide\n   */\n  div(b: BN): BN;\n\n  /**\n   * @description divide\n   */\n  divn(b: number): BN;\n\n  /**\n   * @description divide\n   */\n  idivn(b: number): BN;\n\n  /**\n   * @description reduct\n   */\n  mod(b: BN): BN;\n\n  /**\n   * @description reduct\n   */\n  umod(b: BN): BN;\n\n  /**\n   * @see API consistency https://github.com/indutny/bn.js/pull/130\n   * @description reduct\n   */\n  modn(b: number): number;\n\n  /**\n   * @description  rounded division\n   */\n  divRound(b: BN): BN;\n\n  /**\n   * @description or\n   */\n  or(b: BN): BN;\n\n  /**\n   * @description or\n   */\n  ior(b: BN): BN;\n\n  /**\n   * @description or\n   */\n  uor(b: BN): BN;\n\n  /**\n   * @description or\n   */\n  iuor(b: BN): BN;\n\n  /**\n   * @description and\n   */\n  and(b: BN): BN;\n\n  /**\n   * @description and\n   */\n  iand(b: BN): BN;\n\n  /**\n   * @description and\n   */\n  uand(b: BN): BN;\n\n  /**\n   * @description and\n   */\n  iuand(b: BN): BN;\n\n  /**\n   * @description and (NOTE: `andln` is going to be replaced with `andn` in future)\n   */\n  andln(b: number): BN;\n\n  /**\n   * @description xor\n   */\n  xor(b: BN): BN;\n\n  /**\n   * @description xor\n   */\n  ixor(b: BN): BN;\n\n  /**\n   * @description xor\n   */\n  uxor(b: BN): BN;\n\n  /**\n   * @description xor\n   */\n  iuxor(b: BN): BN;\n\n  /**\n   * @description set specified bit to 1\n   */\n  setn(b: number): BN;\n\n  /**\n   * @description shift left\n   */\n  shln(b: number): BN;\n\n  /**\n   * @description shift left\n   */\n  ishln(b: number): BN;\n\n  /**\n   * @description shift left\n   */\n  ushln(b: number): BN;\n\n  /**\n   * @description shift left\n   */\n  iushln(b: number): BN;\n\n  /**\n   * @description shift right\n   */\n  shrn(b: number): BN;\n\n  /**\n   * @description shift right (unimplemented https://github.com/indutny/bn.js/blob/master/lib/bn.js#L2086)\n   */\n  ishrn(b: number): BN;\n\n  /**\n   * @description shift right\n   */\n  ushrn(b: number): BN;\n  /**\n   * @description shift right\n   */\n\n  iushrn(b: number): BN;\n  /**\n   * @description  test if specified bit is set\n   */\n\n  testn(b: number): boolean;\n  /**\n   * @description clear bits with indexes higher or equal to `b`\n   */\n\n  maskn(b: number): BN;\n  /**\n   * @description clear bits with indexes higher or equal to `b`\n   */\n\n  imaskn(b: number): BN;\n  /**\n   * @description add `1 << b` to the number\n   */\n  bincn(b: number): BN;\n\n  /**\n   * @description not (for the width specified by `w`)\n   */\n  notn(w: number): BN;\n\n  /**\n   * @description not (for the width specified by `w`)\n   */\n  inotn(w: number): BN;\n\n  /**\n   * @description GCD\n   */\n  gcd(b: BN): BN;\n\n  /**\n   * @description Extended GCD results `({ a: ..., b: ..., gcd: ... })`\n   */\n  egcd(b: BN): { a: BN; b: BN; gcd: BN };\n\n  /**\n   * @description inverse `a` modulo `b`\n   */\n  invm(b: BN): BN;\n\n  /**\n   * @description Convert number to red\n   */\n  toRed(reductionContext: ReductionContext): RedBN;\n}\n\n/**\n * Big-Number interface  with additionnal methods that are using modular\n * operation.\n */\ndeclare interface RedBN extends BN {\n  /**\n   * @description Convert back a number using a reduction context\n   */\n  fromRed(): BN;\n\n  /**\n   * @description modular addition\n   */\n  redAdd(b: BN): RedBN;\n\n  /**\n   * @description in-place modular addition\n   */\n  redIAdd(b: BN): RedBN;\n\n  /**\n   * @description modular subtraction\n   */\n  redSub(b: BN): RedBN;\n\n  /**\n   * @description in-place modular subtraction\n   */\n  redISub(b: BN): RedBN;\n\n  /**\n   * @description modular shift left\n   */\n  redShl(num: number): RedBN;\n\n  /**\n   * @description modular multiplication\n   */\n  redMul(b: BN): RedBN;\n\n  /**\n   * @description in-place modular multiplication\n   */\n  redIMul(b: BN): RedBN;\n\n  /**\n   * @description modular square\n   */\n  redSqr(): RedBN;\n\n  /**\n   * @description in-place modular square\n   */\n  redISqr(): RedBN;\n\n  /**\n   * @description modular square root\n   */\n  redSqrt(): RedBN;\n\n  /**\n   * @description modular inverse of the number\n   */\n  redInvm(): RedBN;\n\n  /**\n   * @description modular negation\n   */\n  redNeg(): RedBN;\n\n  /**\n   * @description modular exponentiation\n   */\n  redPow(b: BN): RedBN;\n}\n\ndeclare interface SignedTransaction {\n  messageHash?: string;\n  r: string;\n  s: string;\n  v: string;\n  rawTransaction?: string;\n  transactionHash?: string;\n}\n\ndeclare interface Extension {\n  property?: string,\n  methods: any[]\n}\n\ndeclare interface Providers {\n  HttpProvider: any;\n  WebsocketProvider: new (\n    host: string,\n    options?: any\n  ) => any;\n  IpcProvider: new (path: string, net: any) => IpcProvider;\n}\n\ndeclare interface PromiEvent<T> extends Promise<T> {\n  once(\n    type: 'transactionHash',\n    handler: (receipt: string) => void\n  ): PromiEvent<T>;\n\n  once(\n    type: 'receipt',\n    handler: (receipt: TransactionReceipt) => void\n  ): PromiEvent<T>;\n\n  once(\n    type: 'confirmation',\n    handler: (confNumber: number, receipt: TransactionReceipt) => void\n  ): PromiEvent<T>;\n\n  once(type: 'error', handler: (error: Error) => void): PromiEvent<T>;\n\n  once(\n    type: 'error' | 'confirmation' | 'receipt' | 'transactionHash',\n    handler: (error: Error | TransactionReceipt | string) => void\n  ): PromiEvent<T>;\n\n  on(\n    type: 'transactionHash',\n    handler: (receipt: string) => void\n  ): PromiEvent<T>;\n\n  on(\n    type: 'receipt',\n    handler: (receipt: TransactionReceipt) => void\n  ): PromiEvent<T>;\n\n  on(\n    type: 'confirmation',\n    handler: (confNumber: number, receipt: TransactionReceipt) => void\n  ): PromiEvent<T>;\n\n  on(type: 'error', handler: (error: Error) => void): PromiEvent<T>;\n\n  on(\n    type: 'error' | 'confirmation' | 'receipt' | 'transactionHash',\n    handler: (error: Error | TransactionReceipt | string) => void\n  ): PromiEvent<T>;\n}\n\ndeclare interface Transaction {\n  hash: string;\n  nonce: number;\n  blockHash: string | null;\n  blockNumber: number | null;\n  transactionIndex: number | null;\n  from: string;\n  to: string | null;\n  value: string;\n  gasPrice: string;\n  gas: number;\n  input: string;\n}\n\ndeclare interface TransactionConfig {\n  from?: string | number;\n  to?: string;\n  value?: number | string | BN;\n  gas?: number | string;\n  gasPrice?: number | string | BN;\n  data?: string;\n  nonce?: number;\n  chainId?: number;\n  common?: Common;\n  chain?: string;\n  hardfork?: string;\n}\n\ndeclare type chain =\n  | 'mainnet'\n  | 'goerli'\n  | 'kovan'\n  | 'rinkeby'\n  | 'ropsten';\n\ndeclare type hardfork =\n  | 'chainstart'\n  | 'homestead'\n  | 'dao'\n  | 'tangerineWhistle'\n  | 'spuriousDragon'\n  | 'byzantium'\n  | 'constantinople'\n  | 'petersburg'\n  | 'istanbul';\n\ndeclare interface Common {\n  customChain: CustomChainParams;\n  baseChain?: chain;\n  hardfork?: hardfork;\n}\n\ndeclare interface CustomChainParams {\n  name?: string;\n  networkId: number;\n  chainId: number;\n}\n\ndeclare interface RLPEncodedTransaction {\n  raw: string;\n  tx: {\n    nonce: string;\n    gasPrice: string;\n    gas: string;\n    to: string;\n    value: string;\n    input: string;\n    r: string;\n    s: string;\n    v: string;\n    hash: string;\n  };\n}\n\ndeclare interface TransactionReceipt {\n  status: boolean;\n  transactionHash: string;\n  transactionIndex: number;\n  blockHash: string;\n  blockNumber: number;\n  from: string;\n  to: string;\n  contractAddress?: string;\n  cumulativeGasUsed: number;\n  gasUsed: number;\n  logs: Log[];\n  logsBloom: string;\n  events?: {\n    [eventName: string]: EventLog;\n  };\n}\n\ndeclare interface EventLog {\n  event: string;\n  address: string;\n  returnValues: any;\n  logIndex: number;\n  transactionIndex: number;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  raw?: { data: string; topics: any[] };\n}\n\ndeclare interface Log {\n  address: string;\n  data: string;\n  topics: Array<string | string[]>;\n  logIndex: number;\n  transactionIndex: number;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n}\n\n// had to move `web3-net` due to other modules in `1.x` not referencing\n\ndeclare interface NetworkBase {\n  constructor(provider: provider, net?: any | null);\n\n  readonly givenProvider: any;\n  readonly currentProvider: provider;\n  BatchRequest: new () => BatchRequest;\n  readonly providers: Providers;\n\n  setProvider(provider: provider): boolean;\n\n  extend(extension: Extension): any;\n\n  getNetworkType(\n    callback?: (error: Error, returnValue: string) => void\n  ): Promise<string>;\n\n  getId(callback?: (error: Error, id: number) => void): Promise<number>;\n\n  isListening(\n    callback?: (error: Error, listening: boolean) => void\n  ): Promise<boolean>;\n\n  getPeerCount(\n    callback?: (error: Error, peerCount: number) => void\n  ): Promise<number>;\n}\n\n// had to move accounts from web3-eth-accounts due to other modules in 1.x not referencing\n\ndeclare interface AccountsBase {\n  constructor(provider: provider, net?: any | null);\n\n  readonly givenProvider: any;\n  readonly currentProvider: provider;\n  BatchRequest: new () => BatchRequest;\n  readonly providers: Providers;\n\n  setProvider(provider: provider): boolean;\n\n  extend(extension: Extension): any;\n\n  create(entropy?: string): Account;\n\n  privateKeyToAccount(privateKey: string): Account;\n\n  signTransaction(\n    transactionConfig: TransactionConfig,\n    privateKey: string,\n    callback?: () => void\n  ): Promise<SignedTransaction>;\n\n  recoverTransaction(signature: string): string;\n\n  hashMessage(message: string): string;\n\n  sign(data: string, privateKey: string): Sign;\n\n  recover(signatureObject: SignatureObject): string;\n  recover(message: string, signature: string, preFixed?: boolean): string;\n  recover(\n    message: string,\n    v: string,\n    r: string,\n    s: string,\n    preFixed?: boolean\n  ): string;\n\n  encrypt(privateKey: string, password: string): EncryptedKeystoreV3Json;\n\n  decrypt(keystoreJsonV3: EncryptedKeystoreV3Json, password: string): Account;\n\n  wallet: WalletBase;\n}\n\ndeclare interface WalletBase {\n  constructor(accounts: AccountsBase);\n\n  length: number;\n  defaultKeyName: string;\n\n  [key: number]: Account;\n\n  create(numberOfAccounts: number, entropy?: string): WalletBase;\n\n  add(account: string | AddAccount): AddedAccount;\n\n  remove(account: string | number): boolean;\n\n  clear(): WalletBase;\n\n  encrypt(password: string): EncryptedKeystoreV3Json[];\n\n  decrypt(\n    keystoreArray: EncryptedKeystoreV3Json[],\n    password: string\n  ): WalletBase;\n\n  save(password: string, keyName?: string): boolean;\n\n  load(password: string, keyName?: string): WalletBase;\n}\n\ndeclare interface AddAccount {\n  address: string;\n  privateKey: string;\n}\n\ndeclare interface AddedAccount extends Account {\n  index: number;\n}\n\ndeclare interface Account {\n  address: string;\n  privateKey: string;\n  signTransaction: (\n    transactionConfig: TransactionConfig,\n    callback?: (signTransaction: SignedTransaction) => void\n  ) => Promise<SignedTransaction>;\n  sign: (data: string) => Sign;\n  encrypt: (password: string) => EncryptedKeystoreV3Json;\n}\n\ndeclare interface EncryptedKeystoreV3Json {\n  version: number;\n  id: string;\n  address: string;\n  crypto: {\n    ciphertext: string;\n    cipherparams: { iv: string };\n    cipher: string;\n    kdf: string;\n    kdfparams: {\n      dklen: number;\n      salt: string;\n      n: number;\n      r: number;\n      p: number;\n    };\n    mac: string;\n  };\n}\n\ndeclare interface Sign extends SignedTransaction {\n  message: string;\n  signature: string;\n}\n\ndeclare interface SignatureObject {\n  messageHash: string;\n  r: string;\n  s: string;\n  v: string;\n}\n\n// put all the `web3-provider` typings in here so we can get to them everywhere as this module does not exist in 1.x\n\ndeclare interface BatchRequest {\n  constructor();\n\n  add(method: any): void;\n\n  execute(): void;\n}\n\ndeclare interface HttpProvider {\n  constructor(host: string, options?: any);\n}\n\ndeclare interface IpcProvider {\n  constructor(path: string, net: any);\n}\n\ndeclare interface WebsocketProvider {\n  constructor(host: string, options?: any);\n\n  isConnecting(): boolean;\n}\n\ndeclare type provider =\n  | HttpProvider\n  | IpcProvider\n  | WebsocketProvider\n  | string\n  | null;\n\n\ndeclare type Unit =\n  | 'noether'\n  | 'wei'\n  | 'kwei'\n  | 'Kwei'\n  | 'babbage'\n  | 'femtoether'\n  | 'mwei'\n  | 'Mwei'\n  | 'lovelace'\n  | 'picoether'\n  | 'gwei'\n  | 'Gwei'\n  | 'shannon'\n  | 'nanoether'\n  | 'nano'\n  | 'szabo'\n  | 'microether'\n  | 'micro'\n  | 'finney'\n  | 'milliether'\n  | 'milli'\n  | 'ether'\n  | 'kether'\n  | 'grand'\n  | 'mether'\n  | 'gether'\n  | 'tether';\n\ndeclare type Mixed =\n  | string\n  | number\n  | BN\n  | {\n    type: string;\n    value: string;\n  }\n  | {\n    t: string;\n    v: string | BN | number;\n  }\n  | boolean;\n\ndeclare type Hex = string | number;\n\n// utils types\ndeclare function isBN(value: string | number): boolean;\ndeclare function isBigNumber(value: BN): boolean;\ndeclare function toBN(value: number | string): BN;\ndeclare function toTwosComplement(value: number | string | BN): string;\ndeclare function isAddress(address: string, chainId?: number): boolean;\ndeclare function isHex(hex: Hex): boolean;\ndeclare function isHexStrict(hex: Hex): boolean;\ndeclare function asciiToHex(string: string, length?: number): string;\ndeclare function hexToAscii(string: string): string;\ndeclare function toAscii(string: string): string;\ndeclare function bytesToHex(bytes: number[]): string;\ndeclare function numberToHex(value: number | string | BN): string;\ndeclare function checkAddressChecksum(address: string, chainId?: number): boolean;\ndeclare function fromAscii(string: string): string;\ndeclare function fromDecimal(value: string | number): string;\ndeclare function fromUtf8(string: string): string;\ndeclare function fromWei(value: string | BN, unit?: Unit): string;\ndeclare function hexToBytes(hex: Hex): number[];\ndeclare function hexToNumber(hex: Hex): number;\ndeclare function hexToNumberString(hex: Hex): string;\ndeclare function hexToString(hex: Hex): string;\ndeclare function hexToUtf8(string: string): string;\ndeclare function keccak256(value: string | BN): string;\ndeclare function padLeft(value: string | number, characterAmount: number, sign?: string): string;\ndeclare function leftPad(string: string | number, characterAmount: number, sign?: string): string;\ndeclare function rightPad(string: string | number, characterAmount: number, sign?: string): string;\ndeclare function padRight(string: string | number, characterAmount: number, sign?: string): string;\ndeclare function sha3(value: string | BN): string;\ndeclare function randomHex(bytesSize: number): string;\ndeclare function utf8ToHex(string: string): string;\ndeclare function stringToHex(string: string): string;\ndeclare function toChecksumAddress(address: string, chainId?: number): string;\ndeclare function toDecimal(hex: Hex): number;\ndeclare function toHex(value: number | string | BN): string;\ndeclare function toUtf8(string: string): string;\ndeclare function toWei(val: BN, unit?: Unit): BN;\ndeclare function toWei(val: string, unit?: Unit): string;\ndeclare function isBloom(bloom: string): boolean;\ndeclare function isInBloom(bloom: string, value: string | Uint8Array): boolean;\ndeclare function isUserEthereumAddressInBloom(bloom: string, ethereumAddress: string): boolean;\ndeclare function isContractAddressInBloom(bloom: string, contractAddress: string): boolean;\ndeclare function isTopicInBloom(bloom: string, topic: string): boolean;\ndeclare function isTopic(topic: string): boolean;\ndeclare function jsonInterfaceMethodToString(abiItem: AbiItem): string;\ndeclare function soliditySha3(...val: Mixed[]): string;\ndeclare function getUnitValue(unit: Unit): string;\ndeclare function unitMap(): Units;\ndeclare function testAddress(bloom: string, address: string): boolean;\ndeclare function testTopic(bloom: string, topic: string): boolean;\ndeclare function getSignatureParameters(signature: string): { r: string; s: string; v: number };\ndeclare function stripHexPrefix(str: string): string;\n\n// interfaces\ndeclare interface Utils {\n  isBN(value: string | number): boolean;\n  isBigNumber(value: BN): boolean;\n  toBN(value: number | string): BN;\n  toTwosComplement(value: number | string | BN): string;\n  isAddress(address: string, chainId?: number): boolean;\n  isHex(hex: Hex): boolean;\n  isHexStrict(hex: Hex): boolean;\n  asciiToHex(string: string, length?: number): string;\n  hexToAscii(string: string): string;\n  toAscii(string: string): string;\n  bytesToHex(bytes: number[]): string;\n  numberToHex(value: number | string | BN): string;\n  checkAddressChecksum(address: string, chainId?: number): boolean;\n  fromAscii(string: string): string;\n  fromDecimal(value: string | number): string;\n  fromUtf8(string: string): string;\n  fromWei(value: string | BN, unit?: Unit): string;\n  hexToBytes(hex: Hex): number[];\n  hexToNumber(hex: Hex): number;\n  hexToNumberString(hex: Hex): string;\n  hexToString(hex: Hex): string;\n  hexToUtf8(string: string): string;\n  keccak256(value: string | BN): string;\n  padLeft(value: string | number, characterAmount: number, sign?: string): string;\n  leftPad(string: string | number, characterAmount: number, sign?: string): string;\n  rightPad(string: string | number, characterAmount: number, sign?: string): string;\n  padRight(string: string | number, characterAmount: number, sign?: string): string;\n  sha3(value: string | BN): string;\n  randomHex(bytesSize: number): string;\n  utf8ToHex(string: string): string;\n  stringToHex(string: string): string;\n  toChecksumAddress(address: string, chainId?: number): string;\n  toDecimal(hex: Hex): number;\n  toHex(value: number | string | BN): string;\n  toUtf8(string: string): string;\n  toWei(val: BN, unit?: Unit): BN;\n  toWei(val: string, unit?: Unit): string;\n  isBloom(bloom: string): boolean;\n  isInBloom(bloom: string, value: string | Uint8Array): boolean;\n  isUserEthereumAddressInBloom(bloom: string, ethereumAddress: string): boolean;\n  isContractAddressInBloom(bloom: string, contractAddress: string): boolean;\n  isTopicInBloom(bloom: string, topic: string): boolean;\n  isTopic(topic: string): boolean;\n  jsonInterfaceMethodToString(abiItem: AbiItem): string;\n  soliditySha3(...val: Mixed[]): string;\n  getUnitValue(unit: Unit): string;\n  unitMap(): Units;\n  testAddress(bloom: string, address: string): boolean;\n  testTopic(bloom: string, topic: string): boolean;\n  getSignatureParameters(signature: string): { r: string; s: string; v: number };\n  stripHexPrefix(str: string): string;\n}\n\ndeclare interface Units {\n  noether: string;\n  wei: string;\n  kwei: string;\n  Kwei: string;\n  babbage: string;\n  femtoether: string;\n  mwei: string;\n  Mwei: string;\n  lovelace: string;\n  picoether: string;\n  gwei: string;\n  Gwei: string;\n  shannon: string;\n  nanoether: string;\n  nano: string;\n  szabo: string;\n  microether: string;\n  micro: string;\n  finney: string;\n  milliether: string;\n  milli: string;\n  ether: string;\n  kether: string;\n  grand: string;\n  mether: string;\n  gether: string;\n  tether: string;\n}\n\ndeclare type AbiType = 'function' | 'constructor' | 'event' | 'fallback';\ndeclare type StateMutabilityType = 'pure' | 'view' | 'nonpayable' | 'payable';\n\ndeclare interface AbiItem {\n  anonymous?: boolean;\n  constant?: boolean;\n  inputs?: AbiInput[];\n  name?: string;\n  outputs?: AbiOutput[];\n  payable?: boolean;\n  stateMutability?: StateMutabilityType;\n  type: AbiType;\n}\n\ndeclare interface AbiInput {\n  name: string;\n  type: string;\n  indexed?: boolean;\n  components?: AbiInput[];\n}\n\ndeclare interface AbiOutput {\n  name: string;\n  type: string;\n  components?: AbiOutput[];\n}\n\n\ndeclare interface Subscription<T> {\n  constructor(options: SubscriptionOptions);\n\n  id: string;\n  options: SubscriptionOptions;\n  callback: () => void;\n  arguments: any;\n\n  subscribe(callback?: (error: Error, result: T) => void): Subscription<T>;\n\n  unsubscribe(\n    callback?: (error: Error, result: boolean) => void\n  ): Promise<undefined | boolean>;\n\n  on(type: 'data', handler: (data: T) => void): Subscription<T>;\n\n  on(type: 'changed', handler: (data: T) => void): Subscription<T>;\n\n  on(type: 'error', handler: (data: Error) => void): Subscription<T>;\n}\n\ndeclare interface Subscriptions {\n  constructor(options: SubscriptionsOptions);\n\n  name: string;\n  type: string;\n  subscriptions: SubscriptionsModel;\n  readonly requestManager: any;\n\n  attachToObject(obj: any): void;\n\n  setRequestManager(requestManager: any): void;\n\n  buildCall(): () => any;\n}\n\ndeclare interface SubscriptionOptions {\n  subscription: string;\n  type: string;\n  requestManager: any;\n}\n\ndeclare interface SubscriptionsOptions {\n  name: string;\n  type: string;\n  subscriptions: SubscriptionsModel;\n}\n\ndeclare interface SubscriptionsModel {\n  [name: string]: SubscriptionModel;\n}\n\ndeclare interface SubscriptionModel {\n  subscriptionName: string;\n  params: number;\n  outputFormatter: () => void;\n  inputFormatter: Array<() => void>;\n  subscriptionHandler: () => void;\n}\n\n\ndeclare interface AbiCoder {\n  encodeFunctionSignature(functionName: string | AbiItem): string;\n\n  encodeEventSignature(functionName: string | AbiItem): string;\n\n  encodeParameter(type: any, parameter: any): string;\n\n  encodeParameters(types: any[], paramaters: any[]): string;\n\n  encodeFunctionCall(abiItem: AbiItem, params: string[]): string;\n\n  decodeParameter(type: any, hex: string): { [key: string]: any };\n\n  decodeParameters(types: any[], hex: string): { [key: string]: any };\n\n  decodeLog(\n    inputs: AbiInput[],\n    hex: string,\n    topics: string[]\n  ): { [key: string]: string };\n}\n\n\ndeclare interface Ens {\n  constructor(eth: any);\n\n  registry: Registry;\n\n  resolver(name: string): Promise<Contract>;\n\n  supportsInterface(\n    name: string,\n    interfaceId: string,\n    callback?: (error: Error, supportsInterface: boolean) => void\n  ): Promise<boolean>;\n\n  getAddress(\n    name: string,\n    callback?: (error: Error, address: string) => void\n  ): Promise<string>;\n\n  setAddress(\n    name: string,\n    address: string,\n    sendOptions: TransactionConfig,\n    callback?: (error: Error, result: any) => void\n  ): PromiEvent<any>;\n\n  getPubkey(\n    name: string,\n    callback?: (error: Error, result: { [x: string]: string }) => void\n  ): Promise<{ [x: string]: string }>;\n\n  setPubkey(\n    name: string,\n    x: string,\n    y: string,\n    sendOptions: TransactionConfig,\n    callback?: (error: Error, result: any) => void\n  ): PromiEvent<any>;\n\n  getText(\n    name: string,\n    key: string,\n    callback?: (error: Error, ensName: string) => void\n  ): Promise<string>;\n\n  setText(\n    name: string,\n    key: string,\n    value: string,\n    sendOptions: TransactionConfig,\n    callback?: (error: Error, result: any) => void\n  ): PromiEvent<any>;\n\n  getContent(\n    name: string,\n    callback?: (error: Error, contentHash: string) => void\n  ): Promise<string>;\n\n  setContent(\n    name: string,\n    hash: string,\n    sendOptions: TransactionConfig,\n    callback?: (error: Error, result: any) => void\n  ): PromiEvent<any>;\n\n  getMultihash(\n    name: string,\n    callback?: (error: Error, multihash: string) => void\n  ): Promise<string>;\n\n  setMultihash(\n    name: string,\n    hash: string,\n    sendOptions: TransactionConfig,\n    callback?: (error: Error, result: any) => void\n  ): PromiEvent<any>;\n\n  getContenthash(\n    name: string,\n    callback?: (error: Error, contenthash: string) => void\n  ): Promise<string>;\n\n  setContenthash(\n    name: string,\n    hash: string,\n    sendOptions: TransactionConfig,\n    callback?: (error: Error, result: any) => void\n  ): PromiEvent<any>;\n}\n\ndeclare interface Registry {\n  constructor(ens: Ens);\n\n  ens: Ens;\n\n  contract: Contract | null;\n\n  owner(\n    name: string,\n    callback?: (error: Error, address: string) => void\n  ): Promise<string>;\n\n  resolver(name: string): Promise<Contract>;\n}\n\n\ndeclare interface Accounts extends AccountsBase { }\n\ndeclare interface Wallet extends WalletBase { }\n\ndeclare interface Sign extends SignedTransaction {\n  message: string;\n  signature: string;\n}\n\ndeclare interface SignatureObject {\n  messageHash: string;\n  r: string;\n  s: string;\n  v: string;\n}\n\n\ndeclare interface Personal {\n  constructor(provider: provider);\n\n  newAccount(\n    password: string,\n    callback?: (error: Error, address: string) => void\n  ): Promise<string>;\n\n  sign(\n    dataToSign: string,\n    address: string,\n    password: string,\n    callback?: (error: Error, signature: string) => void\n  ): Promise<string>;\n\n  ecRecover(\n    dataThatWasSigned: string,\n    signature: string,\n    callback?: (error: Error, address: string) => void\n  ): Promise<string>;\n\n  signTransaction(\n    transactionConfig: TransactionConfig,\n    password: string,\n    callback?: (\n      error: Error,\n      RLPEncodedTransaction: RLPEncodedTransaction\n    ) => void\n  ): Promise<RLPEncodedTransaction>;\n\n  sendTransaction(\n    transactionConfig: TransactionConfig,\n    password: string,\n    callback?: (error: Error, transactionHash: string) => void\n  ): Promise<string>;\n\n  unlockAccount(\n    address: string,\n    password: string,\n    unlockDuration: number,\n    callback?: (error: Error) => void\n  ): Promise<boolean>;\n\n  lockAccount(\n    address: string,\n    callback?: (error: Error, success: boolean) => void\n  ): Promise<boolean>;\n\n  getAccounts(\n    callback?: (error: Error, accounts: string[]) => void\n  ): Promise<string[]>;\n\n  importRawKey(\n    privateKey: string,\n    password: string,\n    callback?: (error: Error, result: string) => void\n  ): Promise<string>;\n}\n\ndeclare interface Iban {\n  constructor(\n    iban: string\n  )\n\n  toAddress(iban: string): string;\n\n  toIban(address: string): string;\n\n  fromAddress(address: string): Iban;\n\n  fromBban(bban: string): Iban;\n\n  createIndirect(options: IndirectOptions): Iban;\n\n  isValid(iban: string): boolean;\n\n  isValid(): boolean;\n\n  isDirect(): boolean;\n\n  isIndirect(): boolean;\n\n  checksum(): string;\n\n  institution(): string;\n\n  client(): string;\n\n  toAddress(): string;\n\n  toString(): string;\n}\n\ndeclare interface IndirectOptions {\n  institution: string;\n  identifier: string;\n}\n\ndeclare interface Eth {\n  constructor(currentProvider: provider);\n\n  Contract: new (\n    jsonInterface: AbiItem[] | AbiItem,\n    address?: string,\n    options?: ContractOptions\n  ) => Contract;\n  Iban: new (iban: string) => Iban;\n  personal: Personal;\n  accounts: Accounts;\n  ens: Ens;\n  abi: AbiCoder;\n  net: any;\n\n  readonly givenProvider: any;\n  defaultAccount: string | null;\n  defaultBlock: string | number;\n  defaultCommon: Common;\n  defaultHardfork: hardfork;\n  defaultChain: chain;\n  transactionPollingTimeout: number;\n  transactionConfirmationBlocks: number;\n  transactionBlockTimeout: number;\n  readonly currentProvider: provider;\n  setProvider(provider: provider): boolean;\n  BatchRequest: new () => BatchRequest;\n  readonly providers: Providers;\n  extend(extension: Extension): any;\n\n  clearSubscriptions(callback: (error: Error, result: boolean) => void): void;\n\n  subscribe(\n    type: 'logs',\n    options?: LogsOptions,\n    callback?: (error: Error, log: Log) => void\n  ): Subscription<Log>;\n  subscribe(\n    type: 'syncing',\n    options?: null,\n    callback?: (error: Error, result: Syncing) => void\n  ): Subscription<Syncing>;\n  subscribe(\n    type: 'newBlockHeaders',\n    options?: null,\n    callback?: (error: Error, blockHeader: BlockHeader) => void\n  ): Subscription<BlockHeader>;\n  subscribe(\n    type: 'pendingTransactions',\n    options?: null,\n    callback?: (error: Error, transactionHash: string) => void\n  ): Subscription<string>;\n  subscribe(\n    type: 'pendingTransactions' | 'logs' | 'syncing' | 'newBlockHeaders',\n    options?: null | LogsOptions,\n    callback?: (\n      error: Error,\n      item: Log | Syncing | BlockHeader | string\n    ) => void\n  ): Subscription<Log | BlockHeader | Syncing | string>;\n\n  getProtocolVersion(\n    callback?: (error: Error, protocolVersion: string) => void\n  ): Promise<string>;\n\n  isSyncing(\n    callback?: (error: Error, syncing: Syncing) => void\n  ): Promise<Syncing | boolean>;\n\n  getCoinbase(\n    callback?: (error: Error, coinbaseAddress: string) => void\n  ): Promise<string>;\n\n  isMining(\n    callback?: (error: Error, mining: boolean) => void\n  ): Promise<boolean>;\n\n  getHashrate(\n    callback?: (error: Error, hashes: number) => void\n  ): Promise<number>;\n\n  getNodeInfo(\n    callback?: (error: Error, version: string) => void\n  ): Promise<string>;\n\n  getChainId(\n    callback?: (error: Error, version: number) => void\n  ): Promise<number>;\n\n  getGasPrice(\n    callback?: (error: Error, gasPrice: string) => void\n  ): Promise<string>;\n\n  getAccounts(\n    callback?: (error: Error, accounts: string[]) => void\n  ): Promise<string[]>;\n\n  getBlockNumber(\n    callback?: (error: Error, blockNumber: number) => void\n  ): Promise<number>;\n\n  getBalance(address: string): Promise<string>;\n  getBalance(address: string, defaultBlock: string | number): Promise<string>;\n  getBalance(\n    address: string,\n    callback?: (error: Error, balance: string) => void\n  ): Promise<string>;\n  getBalance(\n    address: string,\n    defaultBlock: string | number,\n    callback?: (error: Error, balance: string) => void\n  ): Promise<string>;\n\n  getStorageAt(address: string, position: number): Promise<string>;\n  getStorageAt(\n    address: string,\n    position: number,\n    defaultBlock: number | string\n  ): Promise<string>;\n  getStorageAt(\n    address: string,\n    position: number,\n    callback?: (error: Error, storageAt: string) => void\n  ): Promise<string>;\n  getStorageAt(\n    address: string,\n    position: number,\n    defaultBlock: number | string,\n    callback?: (error: Error, storageAt: string) => void\n  ): Promise<string>;\n\n  getCode(address: string): Promise<string>;\n  getCode(address: string, defaultBlock: string | number): Promise<string>;\n  getCode(\n    address: string,\n    callback?: (error: Error, code: string) => void\n  ): Promise<string>;\n  getCode(\n    address: string,\n    defaultBlock: string | number,\n    callback?: (error: Error, code: string) => void\n  ): Promise<string>;\n\n  getBlock(blockHashOrBlockNumber: string | number): Promise<Block>;\n  getBlock(\n    blockHashOrBlockNumber: string | number,\n    returnTransactionObjects: boolean\n  ): Promise<Block>;\n  getBlock(\n    blockHashOrBlockNumber: string | number,\n    callback?: (error: Error, block: Block) => void\n  ): Promise<Block>;\n  getBlock(\n    blockHashOrBlockNumber: string | number,\n    returnTransactionObjects: boolean,\n    callback?: (error: Error, block: Block) => void\n  ): Promise<Block>;\n\n  getBlockTransactionCount(\n    blockHashOrBlockNumber: string | number,\n    callback?: (error: Error, numberOfTransactions: number) => void\n  ): Promise<number>;\n\n  getUncle(\n    blockHashOrBlockNumber: string | number,\n    uncleIndex: number\n  ): Promise<Block>;\n  getUncle(\n    blockHashOrBlockNumber: string | number,\n    uncleIndex: number,\n    returnTransactionObjects: boolean\n  ): Promise<Block>;\n  getUncle(\n    blockHashOrBlockNumber: string | number,\n    uncleIndex: number,\n    callback?: (error: Error, uncle: any) => void\n  ): Promise<Block>;\n  getUncle(\n    blockHashOrBlockNumber: string | number,\n    uncleIndex: number,\n    returnTransactionObjects: boolean,\n    callback?: (error: Error, uncle: any) => void\n  ): Promise<Block>;\n\n  getTransaction(\n    transactionHash: string,\n    callback?: (error: Error, transaction: Transaction) => void\n  ): Promise<Transaction>;\n\n  getPendingTransactions(\n    callback?: (error: Error, result: Transaction[]) => void\n  ): Promise<Transaction[]>;\n\n  getTransactionFromBlock(\n    hashStringOrNumber: string | number,\n    indexNumber: number,\n    callback?: (error: Error, transaction: Transaction) => void\n  ): Promise<Transaction>;\n\n  getTransactionReceipt(\n    hash: string,\n    callback?: (\n      error: Error,\n      transactionReceipt: TransactionReceipt\n    ) => void\n  ): Promise<TransactionReceipt>;\n\n  getTransactionCount(address: string): Promise<number>;\n  getTransactionCount(\n    address: string,\n    defaultBlock: number | string\n  ): Promise<number>;\n  getTransactionCount(\n    address: string,\n    callback?: (error: Error, count: number) => void\n  ): Promise<number>;\n  getTransactionCount(\n    address: string,\n    defaultBlock: number | string,\n    callback?: (error: Error, count: number) => void\n  ): Promise<number>;\n\n  sendTransaction(\n    transactionConfig: TransactionConfig,\n    callback?: (error: Error, hash: string) => void\n  ): PromiEvent<TransactionReceipt>;\n\n  sendSignedTransaction(\n    signedTransactionData: string,\n    callback?: (error: Error, hash: string) => void\n  ): PromiEvent<TransactionReceipt>;\n\n  sign(\n    dataToSign: string,\n    address: string | number,\n    callback?: (error: Error, signature: string) => void\n  ): Promise<string>;\n\n  signTransaction(\n    transactionConfig: TransactionConfig,\n    callback?: (\n      error: Error,\n      signedTransaction: RLPEncodedTransaction\n    ) => void\n  ): Promise<RLPEncodedTransaction>;\n  signTransaction(\n    transactionConfig: TransactionConfig,\n    address: string\n  ): Promise<RLPEncodedTransaction>;\n  signTransaction(\n    transactionConfig: TransactionConfig,\n    address: string,\n    callback: (\n      error: Error,\n      signedTransaction: RLPEncodedTransaction\n    ) => void\n  ): Promise<RLPEncodedTransaction>;\n\n  call(transactionConfig: TransactionConfig): Promise<string>;\n  call(\n    transactionConfig: TransactionConfig,\n    defaultBlock?: number | string\n  ): Promise<string>;\n  call(\n    transactionConfig: TransactionConfig,\n    callback?: (error: Error, data: string) => void\n  ): Promise<string>;\n  call(\n    transactionConfig: TransactionConfig,\n    defaultBlock: number | string,\n    callback: (error: Error, data: string) => void\n  ): Promise<string>;\n\n  estimateGas(\n    transactionConfig: TransactionConfig,\n    callback?: (error: Error, gas: number) => void\n  ): Promise<number>;\n\n  getPastLogs(\n    options: PastLogsOptions,\n    callback?: (error: Error, logs: Log[]) => void\n  ): Promise<Log[]>;\n\n  getWork(\n    callback?: (error: Error, result: string[]) => void\n  ): Promise<string[]>;\n\n  submitWork(\n    data: [string, string, string],\n    callback?: (error: Error, result: boolean) => void\n  ): Promise<boolean>;\n\n  getProof(\n    address: string,\n    storageKey: string[],\n    blockNumber: number | string | 'latest' | 'earliest',\n    callback?: (error: Error, result: GetProof) => void\n  ): Promise<GetProof>;\n}\n\ndeclare interface Syncing {\n  StartingBlock: number;\n  CurrentBlock: number;\n  HighestBlock: number;\n  KnownStates: number;\n  PulledStates: number;\n}\n\ndeclare interface BlockHeader {\n  number: number;\n  hash: string;\n  parentHash: string;\n  nonce: string;\n  sha3Uncles: string;\n  logsBloom: string;\n  transactionRoot: string;\n  stateRoot: string;\n  receiptRoot: string;\n  miner: string;\n  extraData: string;\n  gasLimit: number;\n  gasUsed: number;\n  timestamp: number | string;\n}\n\ndeclare interface Block extends BlockHeader {\n  transactions: Transaction[] | string[];\n  size: number;\n  difficulty: number;\n  totalDifficulty: number;\n  uncles: string[];\n}\n\ndeclare interface PastLogsOptions {\n  fromBlock?: number | string;\n  toBlock?: number | string;\n  address?: string | string[];\n  topics?: Array<string | string[]>;\n}\n\ndeclare interface LogsOptions {\n  fromBlock?: number | string;\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\ndeclare interface GetProof {\n  jsonrpc: string;\n  id: number;\n  result: {\n    address: string;\n    accountProof: string[];\n    balance: string;\n    codeHash: string;\n    nonce: string;\n    storageHash: string;\n    storageProof: StorageProof[];\n  };\n}\n\ndeclare interface StorageProof {\n  key: string;\n  value: string;\n  proof: string[];\n}\n\ndeclare interface Bzz {\n  constructor(provider: any);\n\n  readonly givenProvider: any;\n  defaultAccount: string | null;\n  defaultBlock: string | number;\n  readonly currentProvider: any;\n  setProvider(provider: any): boolean;\n  BatchRequest: new () => any;\n  providers: any;\n\n  upload(data: any): Promise<string>;\n\n  download(bzzHash: string, localPath?: string): Promise<any>;\n\n  pick: any;\n}\n\ndeclare interface Web3 {\n  constructor(provider: provider, net?: any);\n\n  modules: Modules;\n  readonly givenProvider: any;\n  defaultAccount: string | null;\n  defaultBlock: string | number;\n  readonly currentProvider: provider;\n  setProvider(provider: provider): boolean;\n  BatchRequest: new () => BatchRequest;\n  readonly providers: Providers;\n\n  utils: Utils;\n  eth: Eth;\n  bzz: Bzz;\n  version: string;\n  extend(extension: Extension): any;\n}\n\ndeclare interface Modules {\n  Eth: new (provider: provider, net: any) => Eth;\n  Net: new (provider: provider, net: any) => NetworkBase;\n  Personal: new (provider: provider, net: any) => Personal;\n  Shh: any;\n  Bzz: new (provider: provider) => Bzz;\n}\n\ndeclare interface ContractOptions {\n  // Sender to use for contract calls\n  from?: string\n  // Gas price to use for contract calls\n  gasPrice?: string\n  // Gas to use for contract calls\n  gas?: number\n  // Contract code\n  data?: string\n}\n\ndeclare interface SendOptions {\n  from: string;\n  gasPrice?: string;\n  gas?: number;\n  value?: number | string | BN;\n}\n\ndeclare interface EstimateGasOptions {\n  from?: string;\n  gas?: number;\n  value?: number | string | BN;\n}\n\ndeclare interface EventOptions {\n  filter?: any;\n  fromBlock?: number;\n  toBlock?: string | number;\n  topics?: any[];\n}\n\ndeclare interface EventData {\n  returnValues: {\n    [key: string]: any;\n  };\n  raw: {\n    data: string;\n    topics: string[];\n  };\n  event: string;\n  signature: string;\n  logIndex: number;\n  transactionIndex: number;\n  transactionHash: string;\n  blockHash: string;\n  blockNumber: number;\n  address: string;\n}\n\n\ndeclare interface Options extends ContractOptions {\n  address: string;\n  jsonInterface: AbiItem[];\n}\n\ndeclare interface DeployOptions {\n  data: string;\n  arguments?: any[];\n}\n\ndeclare interface ContractSendMethod {\n  send(\n    options: SendOptions,\n    callback?: (err: Error, transactionHash: string) => void\n  ): PromiEvent<Contract>;\n\n  estimateGas(\n    options: EstimateGasOptions,\n    callback?: (err: Error, gas: number) => void\n  ): Promise<number>;\n\n  estimateGas(callback: (err: Error, gas: number) => void): Promise<number>;\n\n  estimateGas(\n    options: EstimateGasOptions,\n    callback: (err: Error, gas: number) => void\n  ): Promise<number>;\n\n  estimateGas(options: EstimateGasOptions): Promise<number>;\n\n  estimateGas(): Promise<number>;\n\n  encodeABI(): string;\n}\n\ndeclare interface Contract {\n  defaultAccount: string | null\n  defaultBlock: string | number\n  defaultCommon: Common\n  defaultHardfork: hardfork\n  defaultChain: chain\n  transactionPollingTimeout: number\n  transactionConfirmationBlocks: number\n  transactionBlockTimeout: number\n  options: Options\n  clone(): Contract\n  deploy(options: DeployOptions): ContractSendMethod\n  once(event: string, callback: (error: Error, event: EventData) => void): void\n  once(\n    event: string,\n    options: EventOptions,\n    callback: (error: Error, event: EventData) => void\n  ): void\n  events: any\n  getPastEvents(event: string): Promise<EventData[]>\n  getPastEvents(\n    event: string,\n    options: EventOptions,\n    callback: (error: Error, event: EventData) => void\n  ): Promise<EventData[]>\n  getPastEvents(event: string, options: EventOptions): Promise<EventData[]>\n  getPastEvents(\n    event: string,\n    callback: (error: Error, event: EventData) => void\n  ): Promise<EventData[]>\n\n  contractMethods: any\n}\n\ndeclare var web3: Web3\n",a='\n\ndeclare type Bytes = ArrayLike<number>\ndeclare type BytesLike = Bytes | string\ndeclare type DataOptions = {\n  allowMissingPrefix?: boolean\n  hexPad?: \'left\' | \'right\' | null\n}\ndeclare interface Hexable {\n  toHexString(): string\n}\ndeclare type SignatureLike =\n  | {\n    r: string\n    s?: string\n    _vs?: string\n    recoveryParam?: number\n    v?: number\n  }\n  | BytesLike\ndeclare interface Signature {\n  r: string\n  s: string\n  _vs: string\n  recoveryParam: number\n  v: number\n}\ndeclare function isBytesLike(value: any): value is BytesLike\ndeclare function isBytes(value: any): value is Bytes\ndeclare function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array\ndeclare function concat(items: Array<BytesLike>): Uint8Array\ndeclare function stripZeros(value: BytesLike): Uint8Array\ndeclare function zeroPad(value: BytesLike, length: number): Uint8Array\ndeclare function isHexString(value: any, length?: number): boolean\ndeclare function hexlify(value: BytesLike | Hexable | number, options?: DataOptions): string\ndeclare function hexDataLength(data: BytesLike): number\ndeclare function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string\ndeclare function hexConcat(items: Array<BytesLike>): string\ndeclare function hexValue(value: BytesLike | Hexable | number): string\ndeclare function hexStripZeros(value: BytesLike): string\ndeclare function hexZeroPad(value: BytesLike, length: number): string\ndeclare function splitSignature(signature: SignatureLike): Signature\ndeclare function joinSignature(signature: SignatureLike): string\n\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\ndeclare function getNetwork(network: Networkish): Network\n\ndeclare function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void\ndeclare function getStatic<T>(ctor: any, key: string): T\ndeclare type Deferrable<T> = {\n  [K in keyof T]: T[K] | Promise<T[K]>\n}\ndeclare function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T>\ndeclare function checkProperties(\n  object: any,\n  properties: {\n    [name: string]: boolean\n  }\n): void\ndeclare function shallowCopy<T>(object: T): T\ndeclare function deepCopy<T>(object: T): T\ndeclare class Description<T = any> {\n  constructor(\n    info: {\n      [K in keyof T]: T[K]\n    }\n  )\n}\n\ndeclare type UnsignedTransaction = {\n  to?: string\n  nonce?: number\n  gasLimit?: BigNumberish\n  gasPrice?: BigNumberish\n  data?: BytesLike\n  value?: BigNumberish\n  chainId?: number\n}\ndeclare interface Transaction {\n  hash?: string\n  to?: string\n  from?: string\n  nonce: number\n  gasLimit: BigNumber\n  gasPrice: BigNumber\n  data: string\n  value: BigNumber\n  chainId: number\n  r?: string\n  s?: string\n  v?: number\n}\ndeclare function computeAddress(key: BytesLike | string): string\ndeclare function recoverAddress(digest: BytesLike, signature: SignatureLike): string\ndeclare function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string\ndeclare function parse(rawTransaction: BytesLike): Transaction\n\ndeclare type ConnectionInfo = {\n  url: string\n  user?: string\n  password?: string\n  allowInsecureAuthentication?: boolean\n  throttleLimit?: number\n  timeout?: number\n  headers?: {\n    [key: string]: string | number\n  }\n}\ndeclare interface OnceBlockable {\n  once(eventName: \'block\', handler: () => void): void\n}\ndeclare interface OncePollable {\n  once(eventName: \'poll\', handler: () => void): void\n}\ndeclare type PollOptions = {\n  timeout?: number\n  floor?: number\n  ceiling?: number\n  interval?: number\n  retryLimit?: number\n  onceBlock?: OnceBlockable\n  oncePoll?: OncePollable\n}\ndeclare type FetchJsonResponse = {\n  statusCode: number\n  headers: {\n    [header: string]: string\n  }\n}\ndeclare function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any>\ndeclare function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T>\n\ndeclare type TransactionRequest = {\n  to?: string\n  from?: string\n  nonce?: BigNumberish\n  gasLimit?: BigNumberish\n  gasPrice?: BigNumberish\n  data?: BytesLike\n  value?: BigNumberish\n  chainId?: number\n}\ndeclare interface TransactionResponse extends Transaction {\n  hash: string\n  blockNumber?: number\n  blockHash?: string\n  timestamp?: number\n  confirmations: number\n  from: string\n  raw?: string\n  wait: (confirmations?: number) => Promise<TransactionReceipt>\n}\ndeclare type BlockTag = string | number\ninterface _Block {\n  hash: string\n  parentHash: string\n  number: number\n  timestamp: number\n  nonce: string\n  difficulty: number\n  gasLimit: BigNumber\n  gasUsed: BigNumber\n  miner: string\n  extraData: string\n}\ndeclare interface Block extends _Block {\n  transactions: Array<string>\n}\ndeclare interface BlockWithTransactions extends _Block {\n  transactions: Array<TransactionResponse>\n}\ndeclare interface Log {\n  blockNumber: number\n  blockHash: string\n  transactionIndex: number\n  removed: boolean\n  address: string\n  data: string\n  topics: Array<string>\n  transactionHash: string\n  logIndex: number\n}\ndeclare interface TransactionReceipt {\n  to: string\n  from: string\n  contractAddress: string\n  transactionIndex: number\n  root?: string\n  gasUsed: BigNumber\n  logsBloom: string\n  blockHash: string\n  transactionHash: string\n  logs: Array<Log>\n  blockNumber: number\n  confirmations: number\n  cumulativeGasUsed: BigNumber\n  byzantium: boolean\n  status?: number\n}\ndeclare interface EventFilter {\n  address?: string\n  topics?: Array<string | Array<string>>\n}\ndeclare interface Filter extends EventFilter {\n  fromBlock?: BlockTag\n  toBlock?: BlockTag\n}\ndeclare interface FilterByBlockHash extends EventFilter {\n  blockHash?: string\n}\ndeclare abstract class ForkEvent extends Description {\n  readonly expiry: number\n  readonly _isForkEvent?: boolean\n  static isForkEvent(value: any): value is ForkEvent\n}\ndeclare class BlockForkEvent extends ForkEvent {\n  readonly blockHash: string\n  readonly _isBlockForkEvent?: boolean\n  constructor(blockHash: string, expiry?: number)\n}\ndeclare class TransactionForkEvent extends ForkEvent {\n  readonly hash: string\n  readonly _isTransactionOrderForkEvent?: boolean\n  constructor(hash: string, expiry?: number)\n}\ndeclare class TransactionOrderForkEvent extends ForkEvent {\n  readonly beforeHash: string\n  readonly afterHash: string\n  constructor(beforeHash: string, afterHash: string, expiry?: number)\n}\ndeclare type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent\ndeclare type Listener = (...args: Array<any>) => void\ndeclare abstract class Provider implements OnceBlockable {\n  abstract getNetwork(): Promise<Network>\n  abstract getBlockNumber(): Promise<number>\n  abstract getGasPrice(): Promise<BigNumber>\n  abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>\n  abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>\n  abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>\n  abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>\n  abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>\n  abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>\n  abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>\n  abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>\n  abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>\n  abstract getTransaction(transactionHash: string): Promise<TransactionResponse>\n  abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>\n  abstract getLogs(filter: Filter): Promise<Array<Log>>\n  abstract resolveName(name: string | Promise<string>): Promise<string>\n  abstract lookupAddress(address: string | Promise<string>): Promise<string>\n  abstract on(eventName: EventType, listener: Listener): Provider\n  abstract once(eventName: EventType, listener: Listener): Provider\n  abstract emit(eventName: EventType, ...args: Array<any>): boolean\n  abstract listenerCount(eventName?: EventType): number\n  abstract listeners(eventName?: EventType): Array<Listener>\n  abstract off(eventName: EventType, listener?: Listener): Provider\n  abstract removeAllListeners(eventName?: EventType): Provider\n  addListener(eventName: EventType, listener: Listener): Provider\n  removeListener(eventName: EventType, listener: Listener): Provider\n  abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>\n  readonly _isProvider: boolean\n  constructor()\n  static isProvider(value: any): value is Provider\n}\n\ndeclare interface ExternallyOwnedAccount {\n  readonly address: string\n  readonly privateKey: string\n}\ndeclare abstract class Signer {\n  readonly provider?: Provider\n  abstract getAddress(): Promise<string>\n  abstract signMessage(message: Bytes | string): Promise<string>\n  abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>\n  abstract connect(provider: Provider): Signer\n  readonly _isSigner: boolean\n  constructor()\n  getBalance(blockTag?: BlockTag): Promise<BigNumber>\n  getTransactionCount(blockTag?: BlockTag): Promise<number>\n  estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>\n  call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string>\n  sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>\n  getChainId(): Promise<number>\n  getGasPrice(): Promise<BigNumber>\n  resolveName(name: string): Promise<string>\n  checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest>\n  populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest>\n  _checkProvider(operation?: string): void\n  static isSigner(value: any): value is Signer\n}\ndeclare class VoidSigner extends Signer {\n  readonly address: string\n  constructor(address: string, provider?: Provider)\n  getAddress(): Promise<string>\n  _fail(message: string, operation: string): Promise<any>\n  signMessage(message: Bytes | string): Promise<string>\n  signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>\n  connect(provider: Provider): VoidSigner\n}\n\ndeclare interface Overrides {\n  gasLimit?: BigNumberish | Promise<BigNumberish>\n  gasPrice?: BigNumberish | Promise<BigNumberish>\n  nonce?: BigNumberish | Promise<BigNumberish>\n}\ndeclare interface PayableOverrides extends Overrides {\n  value?: BigNumberish | Promise<BigNumberish>\n}\ndeclare interface CallOverrides extends PayableOverrides {\n  blockTag?: BlockTag | Promise<BlockTag>\n  from?: string | Promise<string>\n}\ndeclare interface PopulatedTransaction {\n  to?: string\n  from?: string\n  nonce?: number\n  gasLimit?: BigNumber\n  gasPrice?: BigNumber\n  data?: string\n  value?: BigNumber\n  chainId?: number\n}\ndeclare type EventFilter = {\n  address?: string\n  topics?: Array<string | Array<string>>\n}\ndeclare type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>\ndeclare interface Event extends Log {\n  event?: string\n  eventSignature?: string\n  args?: Result\n  decodeError?: Error\n  decode?: (data: string, topics?: Array<string>) => any\n  removeListener: () => void\n  getBlock: () => Promise<Block>\n  getTransaction: () => Promise<TransactionResponse>\n  getTransactionReceipt: () => Promise<TransactionReceipt>\n}\ndeclare interface ContractReceipt extends TransactionReceipt {\n  events?: Array<Event>\n}\ndeclare interface ContractTransaction extends TransactionResponse {\n  wait(confirmations?: number): Promise<ContractReceipt>\n}\ndeclare class RunningEvent {\n  readonly tag: string\n  readonly filter: EventFilter\n  private _listeners\n  constructor(tag: string, filter: EventFilter)\n  addListener(listener: Listener, once: boolean): void\n  removeListener(listener: Listener): void\n  removeAllListeners(): void\n  listeners(): Array<Listener>\n  listenerCount(): number\n  run(args: Array<any>): number\n  prepareEvent(event: Event): void\n  getEmit(event: Event): Array<any>\n}\ndeclare type ContractInterface = string | Array<Fragment | JsonFragment | string> | Interface\n\ndeclare class Contract {\n  readonly address: string\n  readonly interface: Interface\n  readonly signer: Signer\n  readonly provider: Provider\n  readonly functions: {\n    [name: string]: ContractFunction\n  }\n  readonly callStatic: {\n    [name: string]: ContractFunction\n  }\n  readonly estimateGas: {\n    [name: string]: ContractFunction<BigNumber>\n  }\n  readonly populateTransaction: {\n    [name: string]: ContractFunction<PopulatedTransaction>\n  }\n  readonly filters: {\n    [name: string]: (...args: Array<any>) => EventFilter\n  }\n  readonly [key: string]: ContractFunction | any\n  readonly resolvedAddress: Promise<string>\n  readonly deployTransaction: TransactionResponse\n  _deployedPromise: Promise<Contract>\n  _runningEvents: {\n    [eventTag: string]: RunningEvent\n  }\n  _wrappedEmits: {\n    [eventTag: string]: (...args: Array<any>) => void\n  }\n  constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider)\n  static getContractAddress(transaction: { from: string; nonce: BigNumberish }): string\n  static getInterface(contractInterface: ContractInterface): Interface\n  deployed(): Promise<Contract>\n  _deployed(blockTag?: BlockTag): Promise<Contract>\n  fallback(overrides?: TransactionRequest): Promise<TransactionResponse>\n  connect(signerOrProvider: Signer | Provider | string): Contract\n  attach(addressOrName: string): Contract\n  static isIndexed(value: any): value is Indexed\n  private _normalizeRunningEvent\n  private _getRunningEvent\n  _checkRunningEvents(runningEvent: RunningEvent): void\n  _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event\n  private _addEventListener\n  queryFilter(event: EventFilter, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>>\n  on(event: EventFilter | string, listener: Listener): this\n  once(event: EventFilter | string, listener: Listener): this\n  emit(eventName: EventFilter | string, ...args: Array<any>): boolean\n  listenerCount(eventName?: EventFilter | string): number\n  listeners(eventName?: EventFilter | string): Array<Listener>\n  removeAllListeners(eventName?: EventFilter | string): this\n  off(eventName: EventFilter | string, listener: Listener): this\n  removeListener(eventName: EventFilter | string, listener: Listener): this\n}\ndeclare class ContractFactory {\n  readonly interface: Interface\n  readonly bytecode: string\n  readonly signer: Signer\n  constructor(\n    contractInterface: ContractInterface,\n    bytecode:\n      | BytesLike\n      | {\n        object: string\n      },\n    signer?: Signer\n  )\n  getDeployTransaction(...args: Array<any>): TransactionRequest\n  deploy(...args: Array<any>): Promise<Contract>\n  attach(address: string): Contract\n  connect(signer: Signer): ContractFactory\n  static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory\n  static getInterface(contractInterface: ContractInterface): Interface\n  static getContractAddress(tx: { from: string; nonce: BytesLike | BigNumber | number }): string\n  static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract\n}\n\ndeclare const wordlists: {\n  [locale: string]: Wordlist\n}\n\ndeclare const defaultPath = "m/44\'/60\'/0\'/0/0"\ndeclare interface Mnemonic {\n  readonly phrase: string\n  readonly path: string\n  readonly locale: string\n}\ndeclare class HDNode implements ExternallyOwnedAccount {\n  readonly privateKey: string\n  readonly publicKey: string\n  readonly fingerprint: string\n  readonly parentFingerprint: string\n  readonly address: string\n  readonly mnemonic?: Mnemonic\n  readonly path: string\n  readonly chainCode: string\n  readonly index: number\n  readonly depth: number\n  /**\n   *  This constructor should not be called directly.\n   *\n   *  Please use:\n   *   - fromMnemonic\n   *   - fromSeed\n   */\n  constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string)\n  get extendedKey(): string\n  neuter(): HDNode\n  private _derive\n  derivePath(path: string): HDNode\n  static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode\n  static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode\n  static fromSeed(seed: BytesLike): HDNode\n  static fromExtendedKey(extendedKey: string): HDNode\n}\ndeclare function mnemonicToSeed(mnemonic: string, password?: string): string\ndeclare function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string\ndeclare function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string\ndeclare function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean\n\ndeclare class SigningKey {\n  readonly curve: string\n  readonly privateKey: string\n  readonly publicKey: string\n  readonly compressedPublicKey: string\n  readonly _isSigningKey: boolean\n  constructor(privateKey: BytesLike)\n  _addPoint(other: BytesLike): string\n  signDigest(digest: BytesLike): Signature\n  computeSharedSecret(otherKey: BytesLike): string\n  static isSigningKey(value: any): value is SigningKey\n}\ndeclare function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string\ndeclare function computePublicKey(key: BytesLike, compressed?: boolean): string\n\ndeclare function decryptJsonWallet(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<ExternallyOwnedAccount>\ndeclare function decryptJsonWalletSync(json: string, password: Bytes | string): ExternallyOwnedAccount\n\ndeclare class Wallet extends Signer implements ExternallyOwnedAccount {\n  readonly address: string\n  readonly provider: Provider\n  readonly _signingKey: () => SigningKey\n  readonly _mnemonic: () => Mnemonic\n  constructor(privateKey: BytesLike | ExternallyOwnedAccount | SigningKey, provider?: Provider)\n  get mnemonic(): Mnemonic\n  get privateKey(): string\n  get publicKey(): string\n  getAddress(): Promise<string>\n  connect(provider: Provider): Wallet\n  signTransaction(transaction: TransactionRequest): Promise<string>\n  signMessage(message: Bytes | string): Promise<string>\n  encrypt(password: Bytes | string, options?: any, progressCallback?: ProgressCallback): Promise<string>\n  /**\n   *  Static methods to create Wallet instances.\n   */\n  static createRandom(options?: any): Wallet\n  static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet>\n  static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet\n  static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet\n}\ndeclare function verifyMessage(message: Bytes | string, signature: SignatureLike): string\n\ndeclare const AddressZero = \'0x0000000000000000000000000000000000000000\'\ndeclare const HashZero = \'0x0000000000000000000000000000000000000000000000000000000000000000\'\ndeclare const EtherSymbol = \'\\u039E\'\ndeclare const NegativeOne: BigNumber\ndeclare const Zero: BigNumber\ndeclare const One: BigNumber\ndeclare const Two: BigNumber\ndeclare const WeiPerEther: BigNumber\ndeclare const MaxUint256: BigNumber\n\ndeclare function getDefaultProvider(network?: Network | string, options?: any): BaseProvider\n\ndeclare enum LogLevel {\n  DEBUG = \'DEBUG\',\n  INFO = \'INFO\',\n  WARNING = \'WARNING\',\n  ERROR = \'ERROR\',\n  OFF = \'OFF\'\n}\ndeclare enum ErrorCode {\n  UNKNOWN_ERROR = \'UNKNOWN_ERROR\',\n  NOT_IMPLEMENTED = \'NOT_IMPLEMENTED\',\n  UNSUPPORTED_OPERATION = \'UNSUPPORTED_OPERATION\',\n  NETWORK_ERROR = \'NETWORK_ERROR\',\n  SERVER_ERROR = \'SERVER_ERROR\',\n  TIMEOUT = \'TIMEOUT\',\n  BUFFER_OVERRUN = \'BUFFER_OVERRUN\',\n  NUMERIC_FAULT = \'NUMERIC_FAULT\',\n  MISSING_NEW = \'MISSING_NEW\',\n  INVALID_ARGUMENT = \'INVALID_ARGUMENT\',\n  MISSING_ARGUMENT = \'MISSING_ARGUMENT\',\n  UNEXPECTED_ARGUMENT = \'UNEXPECTED_ARGUMENT\',\n  CALL_EXCEPTION = \'CALL_EXCEPTION\',\n  INSUFFICIENT_FUNDS = \'INSUFFICIENT_FUNDS\',\n  NONCE_EXPIRED = \'NONCE_EXPIRED\',\n  REPLACEMENT_UNDERPRICED = \'REPLACEMENT_UNDERPRICED\',\n  UNPREDICTABLE_GAS_LIMIT = \'UNPREDICTABLE_GAS_LIMIT\'\n}\ndeclare class Logger {\n  readonly version: string\n  static errors: typeof ErrorCode\n  static levels: typeof LogLevel\n  constructor(version: string)\n  _log(logLevel: LogLevel, args: Array<any>): void\n  debug(...args: Array<any>): void\n  info(...args: Array<any>): void\n  warn(...args: Array<any>): void\n  makeError(message: string, code?: ErrorCode, params?: any): Error\n  throwError(message: string, code?: ErrorCode, params?: any): never\n  throwArgumentError(message: string, name: string, value: any): never\n  checkNormalize(message?: string): void\n  checkSafeUint53(value: number, message?: string): void\n  checkArgumentCount(count: number, expectedCount: number, message?: string): void\n  checkNew(target: any, kind: any): void\n  checkAbstract(target: any, kind: any): void\n  static globalLogger(): Logger\n  static setCensorship(censorship: boolean, permanent?: boolean): void\n  static setLogLevel(logLevel: LogLevel): void\n}\n\ndeclare class AbiCoder {\n  readonly coerceFunc: CoerceFunc\n  constructor(coerceFunc?: CoerceFunc)\n  _getCoder(param: ParamType): Coder\n  _getWordSize(): number\n  _getReader(data: Uint8Array): Reader\n  _getWriter(): Writer\n  encode(types: Array<string | ParamType>, values: Array<any>): string\n  decode(types: Array<string | ParamType>, data: BytesLike): Result\n}\n\ndeclare class utils {\n  AbiCoder: typeof AbiCoder\n  EventFragment()\n  FormatTypes: { sighash: "sighash", minimal: "minimal", full: "full", json: "json" }\n  Fragment(constructorGuard, params)\n  FunctionFragment()\n  HDNode(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath)\n  Indexed()\n  Interface(fragments$1)\n  LogDescription()\n  Logger(version)\n  ParamType(constructorGuard, params)\n  RLP: { __esModule: true, encode: any, decode: any }\n  SigningKey(privateKey)\n  SupportedAlgorithm: { sha256: "sha256", sha512: "sha512" }\n  TransactionDescription()\n  UnicodeNormalizationForm: { current: "", NFC: "NFC", NFD: "NFD", NFKC: "NFKC", NFKD: "NFKD" }\n  Utf8ErrorFuncs: { error: any, ignore: any, replace: any }\n  Utf8ErrorReason: { UNEXPECTED_CONTINUE: "unexpected continuation byte", BAD_PREFIX: "bad codepoint prefix", OVERRUN: "string overrun", MISSING_CONTINUE: "missing continuation byte", OUT_OF_RANGE: "out of UTF-8 range" }\n  arrayify(value, options)\n  base64: { __esModule: true, decode: any, encode: any }\n  checkProperties(object, properties)\n  checkResultErrors(result)\n  commify(value)\n  computeAddress(key)\n  computeHmac(algorithm, key, data)\n  computePublicKey(key, compressed)\n  concat(items)\n  deepCopy(object)\n  defaultAbiCoder: AbiCoder\n  defaultPath: "m/44\'/60\'/0\'/0/0"\n  defineReadOnly(object, name, value)\n  entropyToMnemonic(entropy, wordlist)\n  fetchJson(connection, json, processFunc)\n  formatBytes32String(text)\n  formatEther(wei)\n  formatUnits(value, unitName)\n  getAddress(address)\n  getContractAddress(transaction)\n  getCreate2Address(from, salt, initCodeHash)\n  getIcapAddress(address)\n  getJsonWalletAddress(json)\n  getStatic(ctor, key)\n  hashMessage(message)\n  hexDataLength(data)\n  hexDataSlice(data, offset, endOffset)\n  hexStripZeros(value)\n  hexValue(value)\n  hexZeroPad(value, length)\n  hexlify(value, options)\n  id(text)\n  isAddress(address)\n  isBytes(value)\n  isBytesLike(value)\n  isHexString(value, length)\n  isValidMnemonic(mnemonic, wordlist)\n  isValidName(name)\n  joinSignature(signature)\n  keccak256(data)\n  mnemonicToEntropy(mnemonic, wordlist)\n  mnemonicToSeed(mnemonic, password)\n  namehash(name)\n  nameprep(value)\n  parseBytes32String(bytes)\n  parseEther(ether)\n  parse(rawTransaction)\n  parseUnits(value, unitName)\n  poll(func, options)\n  randomBytes(length)\n  recoverAddress(digest, signature)\n  recoverPublicKey(digest, signature)\n  resolveProperties(object)\n  ripemd160(data)\n  serialize(transaction, signature)\n  sha256(data)\n  sha512(data)\n  shallowCopy(object)\n  shuffled(array)\n  keccak256(types, values)\n  pack(types, values)\n  sha256(types, values)\n  splitSignature(signature)\n  stripZeros(value)\n  toUtf8Bytes(str, form)\n  toUtf8CodePoints(str, form)\n  toUtf8String(bytes, onError)\n  verifyMessage(message, signature)\n  zeroPad(value, length)\n  _toEscapedUtf8String(bytes, onError)\n}\n\ndeclare class JsonRpcSigner extends Signer {\n  readonly provider: JsonRpcProvider\n  _index: number\n  _address: string\n  constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number)\n  connect(provider: Provider): JsonRpcSigner\n  connectUnchecked(): JsonRpcSigner\n  getAddress(): Promise<string>\n  sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>\n  signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>\n  sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>\n  signMessage(message: Bytes | string): Promise<string>\n  _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>\n  unlock(password: string): Promise<boolean>\n}\n\ndeclare class UncheckedJsonRpcSigner extends JsonRpcSigner {\n  sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>\n}\n\ndeclare abstract class JsonRpcProvider {\n  readonly connection: ConnectionInfo\n  _pendingFilter: Promise<number>\n  _nextId: number\n  constructor(url?: ConnectionInfo | string, network?: Networkish)\n  static defaultUrl(): string\n  detectNetwork(): Promise<Network>\n  getSigner(addressOrIndex?: string | number): JsonRpcSigner\n  getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner\n  listAccounts(): Promise<Array<string>>\n  send(method: string, params: Array<any>): Promise<any>\n  prepareRequest(method: string, params: any): [string, Array<any>]\n  perform(method: string, params: any): Promise<any>\n  _startEvent(event: Event): void\n  _startPending(): void\n  _stopEvent(event: Event): void\n  static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: {\n    [key: string]: boolean\n  }): {\n    [key: string]: string\n  }\n}\n\ndeclare abstract class UrlJsonRpcProvider {\n  readonly apiKey: any\n  constructor(network?: Networkish, apiKey?: any)\n  _startPending(): void\n  isCommunityResource(): boolean\n  getSigner(address?: string): JsonRpcSigner\n  listAccounts(): Promise<Array<string>>\n  static getApiKey(apiKey: any): any\n  static getUrl(network: Network, apiKey: any): string | ConnectionInfo\n}\n\ndeclare class AlchemyProvider extends UrlJsonRpcProvider {\n  static getWebSocketProvider(network, apiKey): Provider\n  static getApiKey(apiKey): string\n  static getUrl(network, apiKey): string\n}\n\ndeclare class InfuraProvider extends UrlJsonRpcProvider {\n  static getWebSocketProvider(network, apiKey): Provider\n  static getApiKey(apiKey): string\n  static getUrl(network, apiKey): string\n}\n\ndeclare class IpcProvider extends JsonRpcProvider {\n  readonly path: string\n  constructor(path: string, network?: Networkish)\n  send(method: string, params: Array<any>): Promise<any>\n}\n\ndeclare class NodesmithProvider extends UrlJsonRpcProvider {\n  static getApiKey(apiKey: any): any\n  static getUrl(network: Network, apiKey?: any): string\n}\n\ndeclare class Web3Provider extends JsonRpcProvider {\n  readonly provider: ExternalProvider\n  readonly jsonRpcFetchFunc: JsonRpcFetchFunc\n  constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish)\n  new(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish)\n  send(method: string, params: Array<any>): Promise<any>\n}\n\ndeclare class WebSocketProvider extends JsonRpcProvider {\n  readonly _websocket: any\n  constructor(url: string, network?: Networkish)\n  get pollingInterval(): number\n  resetEventsBlock(blockNumber: number): void\n  set pollingInterval(value: number)\n  poll(): Promise<void>\n  set polling(value: boolean)\n  send(method: string, params?: Array<any>): Promise<any>\n  static defaultUrl(): string\n  _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void>\n  _startEvent(event: Event): void\n  _stopEvent(event: Event): void\n}\n\ndeclare class CloudflareProvider extends UrlJsonRpcProvider {\n  static getApiKey(apiKey: any): any\n  static getUrl(network: Network, apiKey?: any): string\n  perform(method: string, params: any): Promise<any>\n}\n\ndeclare class Ethers {\n  BigNumber: BigNumber\n  Contract: Contract\n  ContractFactory: Contract\n  FixedNumber: FixedNumber\n  Signer: Signer\n  VoidSigner: VoidSigner\n  Wallet: Wallet\n  Wordlist: Wordlist\n  constants: {\n    AddressZero: "0x0000000000000000000000000000000000000000"\n    EtherSymbol: "\u039e"\n    HashZero: "0x0000000000000000000000000000000000000000000000000000000000000000"\n    MaxUint256: BigNumber\n    NegativeOne: BigNumber\n    One: BigNumber\n    Two: BigNumber\n    WeiPerEther: BigNumber\n    Zero: BigNumber\n  }\n  errors: {\n    BUFFER_OVERRUN: "BUFFER_OVERRUN"\n    CALL_EXCEPTION: "CALL_EXCEPTION"\n    INSUFFICIENT_FUNDS: "INSUFFICIENT_FUNDS"\n    INVALID_ARGUMENT: "INVALID_ARGUMENT"\n    MISSING_ARGUMENT: "MISSING_ARGUMENT"\n    MISSING_NEW: "MISSING_NEW"\n    NETWORK_ERROR: "NETWORK_ERROR"\n    NONCE_EXPIRED: "NONCE_EXPIRED"\n    NOT_IMPLEMENTED: "NOT_IMPLEMENTED"\n    NUMERIC_FAULT: "NUMERIC_FAULT"\n    REPLACEMENT_UNDERPRICED: "REPLACEMENT_UNDERPRICED"\n    SERVER_ERROR: "SERVER_ERROR"\n    TIMEOUT: "TIMEOUT"\n    UNEXPECTED_ARGUMENT: "UNEXPECTED_ARGUMENT"\n    UNKNOWN_ERROR: "UNKNOWN_ERROR"\n    UNPREDICTABLE_GAS_LIMIT: "UNPREDICTABLE_GAS_LIMIT"\n    UNSUPPORTED_OPERATION: "UNSUPPORTED_OPERATION"\n  }\n  getDefaultProvider(network, options): Provider\n  logger: { version: "ethers/5.0.4" }\n  providers: {\n    AlchemyProvider: typeof AlchemyProvider\n    BaseProvider: typeof BaseProvider\n    CloudflareProvider: typeof CloudflareProvider\n    EtherscanProvider: typeof EtherscanProvider\n    FallbackProvider: typeof FallbackProvider\n    Formatter: typeof Formatter\n    InfuraProvider: typeof InfuraProvider\n    IpcProvider: typeof null\n    JsonRpcProvider: typeof JsonRpcProvider\n    JsonRpcSigner: typeof JsonRpcSigner\n    NodesmithProvider: typeof NodesmithProvider\n    Provider: typeof Provider\n    StaticJsonRpcProvider: typeof StaticJsonRpcProvider\n    UrlJsonRpcProvider: typeof UrlJsonRpcProvider\n    Web3Provider: typeof Web3Provider\n    WebSocketProvider: typeof WebSocketProvider\n    getDefaultProvider: typeof getDefaultProvider\n    getNetwork: typeof getNetwork\n  }\n  utils: utils\n  version: "ethers/5.0.4"\n}\n\ndeclare const logger: utils.Logger\n\ndeclare const provider: Provider\n\ndeclare const ethers: Ethers\n',i="declare type Bytes = ArrayLike<number>\ndeclare type BytesLike = Bytes | string\ndeclare type DataOptions = {\n  allowMissingPrefix?: boolean\n  hexPad?: 'left' | 'right' | null\n}\ndeclare interface Hexable {\n  toHexString(): string\n}\ndeclare type SignatureLike =\n  | {\n    r: string\n    s?: string\n    _vs?: string\n    recoveryParam?: number\n    v?: number\n  }\n  | BytesLike\ndeclare interface Signature {\n  r: string\n  s: string\n  _vs: string\n  recoveryParam: number\n  v: number\n}\ndeclare function isBytesLike(value: any): value is BytesLike\ndeclare function isBytes(value: any): value is Bytes\ndeclare function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array\ndeclare function concat(items: Array<BytesLike>): Uint8Array\ndeclare function stripZeros(value: BytesLike): Uint8Array\ndeclare function zeroPad(value: BytesLike, length: number): Uint8Array\ndeclare function isHexString(value: any, length?: number): boolean\ndeclare function hexlify(value: BytesLike | Hexable | number, options?: DataOptions): string\ndeclare function hexDataLength(data: BytesLike): number\ndeclare function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string\ndeclare function hexConcat(items: Array<BytesLike>): string\ndeclare function hexValue(value: BytesLike | Hexable | number): string\ndeclare function hexStripZeros(value: BytesLike): string\ndeclare function hexZeroPad(value: BytesLike, length: number): string\ndeclare function splitSignature(signature: SignatureLike): Signature\ndeclare function joinSignature(signature: SignatureLike): string\n\ndeclare type BigNumberish = BigNumber | Bytes | string | number\ndeclare function isBigNumberish(value: any): value is BigNumberish\ndeclare class BigNumber implements Hexable {\n  readonly _hex: string\n  readonly _isBigNumber: boolean\n  constructor(constructorGuard: any, hex: string)\n  fromTwos(value: number): BigNumber\n  toTwos(value: number): BigNumber\n  abs(): BigNumber\n  add(other: BigNumberish): BigNumber\n  sub(other: BigNumberish): BigNumber\n  div(other: BigNumberish): BigNumber\n  mul(other: BigNumberish): BigNumber\n  mod(other: BigNumberish): BigNumber\n  pow(other: BigNumberish): BigNumber\n  and(other: BigNumberish): BigNumber\n  or(other: BigNumberish): BigNumber\n  xor(other: BigNumberish): BigNumber\n  mask(value: number): BigNumber\n  shl(value: number): BigNumber\n  shr(value: number): BigNumber\n  eq(other: BigNumberish): boolean\n  lt(other: BigNumberish): boolean\n  lte(other: BigNumberish): boolean\n  gt(other: BigNumberish): boolean\n  gte(other: BigNumberish): boolean\n  isNegative(): boolean\n  isZero(): boolean\n  toNumber(): number\n  toString(): string\n  toHexString(): string\n  static from(value: any): BigNumber\n  static isBigNumber(value: any): value is BigNumber\n}\n\ndeclare class FixedNumber {\n  readonly format: FixedFormat\n  readonly _hex: string\n  readonly _value: string\n  readonly _isFixedNumber: boolean\n  constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat)\n  _checkFormat(other: FixedNumber): void\n  addUnsafe(other: FixedNumber): FixedNumber\n  subUnsafe(other: FixedNumber): FixedNumber\n  mulUnsafe(other: FixedNumber): FixedNumber\n  divUnsafe(other: FixedNumber): FixedNumber\n  floor(): FixedNumber\n  ceiling(): FixedNumber\n  round(decimals?: number): FixedNumber\n  isZero(): boolean\n  isNegative(): boolean\n  toString(): string\n  toHexString(width?: number): string\n  toUnsafeFloat(): number\n  toFormat(format: FixedFormat | string): FixedNumber\n  static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string): FixedNumber\n  static fromString(value: string, format?: FixedFormat | string): FixedNumber\n  static fromBytes(value: BytesLike, format?: FixedFormat | string): FixedNumber\n  static from(value: any, format?: FixedFormat | string): FixedNumber\n  static isFixedNumber(value: any): value is FixedNumber\n}\n",o="/**\n * ************ This is an experimental dev feature ************\n *\n * Ready to use variables:\n * - web3\n * - {varName} with the contract chosed\n *\n * For More info check:\n * https://web3js.readthedocs.io/en/v1.2.2/web3-eth-contract.html#web3-eth-contract\n *\n * Web3 doc:\n * https://web3js.readthedocs.io/en/v1.2.2/\n *\n * The value returned should be convertible to a JSON string.\n *\n * Feedback is welcome :)\n */\n\nasync function main() {\n  /*\n    const name = await contract.methods.name().call()\n    return name\n  */\n}\n",s="/**\n * ************ This is an experimental dev feature ************\n *\n * Ready to use variables:\n * - All ethers modules: Contract, Signer, Provider, Wallet, etc...\n * - 'provider' with window provider\n * - {varName} with the contract chosed\n *\n * For More info check:\n * https://docs.ethers.io/v5/api/contract/contract/\n *\n * Ethers doc:\n * https://docs.ethers.io/v5/api/\n *\n * The value returned should be convertible to a JSON string.\n *\n * Feedback is welcome :)\n */\n\nasync function main() {\n  /*\n    const name = await contract.name()\n    return name\n  */\n}\n",c=r(92);function l(n){switch(n){case c.a.WEB3:return t;case c.a.ETHERS:return i.concat(a);default:return""}}function u(n){switch(n){case c.a.WEB3:return o;case c.a.ETHERS:return s;default:return""}}r.d(e,"b",(function(){return l})),r.d(e,"a",(function(){return u}))},372:function(module,__webpack_exports__,__webpack_require__){"use strict";__webpack_require__.d(__webpack_exports__,"a",(function(){return Editor}));var _Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__(33),_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__),_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__(68),_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__(69),react__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__(14),react__WEBPACK_IMPORTED_MODULE_3___default=__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__),react_monaco_editor__WEBPACK_IMPORTED_MODULE_4__=__webpack_require__(287),react_monaco_editor__WEBPACK_IMPORTED_MODULE_4___default=__webpack_require__.n(react_monaco_editor__WEBPACK_IMPORTED_MODULE_4__),components_Modals__WEBPACK_IMPORTED_MODULE_5__=__webpack_require__(256),libs_contract__WEBPACK_IMPORTED_MODULE_6__=__webpack_require__(157),libs_device__WEBPACK_IMPORTED_MODULE_7__=__webpack_require__(255),libs_localstorage__WEBPACK_IMPORTED_MODULE_8__=__webpack_require__(72),libs_beforeUnload__WEBPACK_IMPORTED_MODULE_9__=__webpack_require__(230),_editorTypes__WEBPACK_IMPORTED_MODULE_10__=__webpack_require__(288),_Editor_css__WEBPACK_IMPORTED_MODULE_11__=__webpack_require__(785),_Editor_css__WEBPACK_IMPORTED_MODULE_11___default=__webpack_require__.n(_Editor_css__WEBPACK_IMPORTED_MODULE_11__),libs_global__WEBPACK_IMPORTED_MODULE_12__=__webpack_require__(375),OUTPUT_HEADLINE="/***** Output *****/\n",currentCode;function Editor(props){var contracts=props.contracts,library=props.library,initCode=props.initCode,isMaximized=props.isMaximized,onChangeSize=props.onChangeSize,isLoading=props.isLoading,defaultScript=Object(_editorTypes__WEBPACK_IMPORTED_MODULE_10__.a)(library),editorTypes=Object(_editorTypes__WEBPACK_IMPORTED_MODULE_10__.b)(library),_useState=Object(react__WEBPACK_IMPORTED_MODULE_3__.useState)(defaultScript),_useState2=Object(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__.a)(_useState,2),code=_useState2[0],setCode=_useState2[1],_useState3=Object(react__WEBPACK_IMPORTED_MODULE_3__.useState)("Copy"),_useState4=Object(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__.a)(_useState3,2),copyText=_useState4[0],setCopyText=_useState4[1],_useState5=Object(react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1),_useState6=Object(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__.a)(_useState5,2),isRunning=_useState6[0],setIsRunning=_useState6[1],_useState7=Object(react__WEBPACK_IMPORTED_MODULE_3__.useState)(null),_useState8=Object(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__.a)(_useState7,2),output=_useState8[0],setOutput=_useState8[1],_useState9=Object(react__WEBPACK_IMPORTED_MODULE_3__.useState)(null),_useState10=Object(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__.a)(_useState9,2),error=_useState10[0],setError=_useState10[1],_useState11=Object(react__WEBPACK_IMPORTED_MODULE_3__.useState)(!1),_useState12=Object(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_2__.a)(_useState11,2),isModalOpen=_useState12[0],setIsModalOpen=_useState12[1],prevContracts=usePrevious(contracts),monacoRef=Object(react__WEBPACK_IMPORTED_MODULE_3__.useRef)(null),textareaRef;currentCode=code;var instanceWindowVars=Object(react__WEBPACK_IMPORTED_MODULE_3__.useCallback)(Object(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__.a)(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark((function n(){return _Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.abrupt("return",Object(libs_global__WEBPACK_IMPORTED_MODULE_12__.a)(library,prevContracts,contracts));case 1:case"end":return n.stop()}}),n)}))),[library,contracts,prevContracts]);function usePrevious(n){var e=Object(react__WEBPACK_IMPORTED_MODULE_3__.useRef)();return Object(react__WEBPACK_IMPORTED_MODULE_3__.useEffect)((function(){e.current=n})),e.current}function editorWillMount(n){n.languages.typescript.typescriptDefaults.addExtraLib(Object(libs_contract__WEBPACK_IMPORTED_MODULE_6__.d)(editorTypes,contracts,library),"index.d.ts"),monacoRef.current=n,instanceWindowVars()}function editorDidMount(n,e){var r=n.getModel();r&&"typescript"===r.getModeId()&&(n.addCommand(e.KeyMod.CtrlCmd|e.KeyCode.KEY_S,(function(){Object(libs_localstorage__WEBPACK_IMPORTED_MODULE_8__.j)(currentCode),n.trigger("format","editor.action.formatDocument",null)})),n.addCommand(e.KeyMod.CtrlCmd|e.KeyCode.Enter,handleExecuteCode),n.addCommand(e.KeyMod.CtrlCmd|e.KeyMod.Shift|e.KeyCode.KEY_E,handleExecuteCode))}function cleanState(){setIsRunning(!0),setOutput(null),setError(null)}function handleExecuteCode(){return _handleExecuteCode.apply(this,arguments)}function _handleExecuteCode(){return _handleExecuteCode=Object(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__.a)(_Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark((function _callee2(){var output,setOutputState;return _Users_duke_du_Documents_00_blockchain_expert_web3playground_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap((function _callee2$(_context2){for(;;)switch(_context2.prev=_context2.next){case 0:return Object(libs_localstorage__WEBPACK_IMPORTED_MODULE_8__.j)(currentCode),setOutputState=function(){void 0===output&&(output="");for(var n=arguments.length,e=new Array(n),r=0;r<n;r++)e[r]=arguments[r];e.length>1?e.forEach((function(n){return output+=JSON.stringify(n,null,2)+"\n"})):output+=JSON.stringify(e[0],null,2)+"\n",setOutput(output)},_context2.prev=2,cleanState(),_context2.t0=setOutputState,_context2.next=7,eval("\n       (function(){\n          const console = {}\n\n          console.log = function() {\n            setOutputState(...arguments)\n          }\n          ".concat(currentCode,"\n          return main()\n        })()\n      "));case 7:_context2.t1=_context2.sent,(0,_context2.t0)(_context2.t1),_context2.next=14;break;case 11:_context2.prev=11,_context2.t2=_context2.catch(2),setError(_context2.t2.stack);case 14:setIsRunning(!1);case 15:case"end":return _context2.stop()}}),_callee2,null,[[2,11]])}))),_handleExecuteCode.apply(this,arguments)}function handleCodeChange(n){Object(libs_beforeUnload__WEBPACK_IMPORTED_MODULE_9__.b)(),setCode(n)}function handleResetCode(){handleCodeChange(defaultScript)}function handleCopy(){if(setCopyText("Copied"),Object(libs_device__WEBPACK_IMPORTED_MODULE_7__.a)()){var n=document.createRange();n.selectNodeContents(textareaRef);var e=window.getSelection();e&&(e.removeAllRanges(),e.addRange(n)),textareaRef.setSelectionRange(0,999999)}else textareaRef.select();document.execCommand("copy"),window.setTimeout((function(){return setCopyText("Copy")}),1e3)}function handleClearOutput(){setOutput(null),setError(null)}function toggleModal(){Object(libs_localstorage__WEBPACK_IMPORTED_MODULE_8__.j)(currentCode),setIsModalOpen(!isModalOpen)}Object(react__WEBPACK_IMPORTED_MODULE_3__.useEffect)((function(){var n;(n=initCode||Object(libs_localstorage__WEBPACK_IMPORTED_MODULE_8__.c)())&&setCode(n)}),[initCode]),Object(react__WEBPACK_IMPORTED_MODULE_3__.useEffect)((function(){monacoRef.current&&!isLoading&&(monacoRef.current.languages.typescript.typescriptDefaults.addExtraLib(Object(libs_contract__WEBPACK_IMPORTED_MODULE_6__.d)(editorTypes,contracts,library),"index.d.ts"),instanceWindowVars())}),[editorTypes,contracts,instanceWindowVars,library,isLoading]);var outputValue=OUTPUT_HEADLINE;return isRunning?outputValue="Running...":output&&(outputValue=output),error&&(outputValue+=error),react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_3___default.a.Fragment,null,react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div",{className:"Editor ".concat(isMaximized?" maximized":"")},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div",{className:"code-wrapper"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div",{className:"actions"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div",{className:"col left"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("button",{onClick:onChangeSize,title:"Hide"},isMaximized?react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("i",{className:"icon hide"}):react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("i",{className:"icon maximize"}),isMaximized?"Minimize":"Maximize"),react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("button",{onClick:handleExecuteCode,title:"Run"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("i",{className:"icon run"}),"Run"),react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("button",{onClick:toggleModal,title:"Upload & Share"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("i",{className:"icon upload"}),"Save & Share")),react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div",{className:"col right"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("button",{onClick:handleResetCode,title:"Reset"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("i",{className:"icon reset"}),"Reset"))),react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(react_monaco_editor__WEBPACK_IMPORTED_MODULE_4___default.a,{language:"typescript",theme:"vs-dark",value:currentCode,onChange:handleCodeChange,editorWillMount:editorWillMount,editorDidMount:editorDidMount,options:{automaticLayout:!0,lineNumbers:"off",minimap:{enabled:!1},fontSize:11}})),react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div",{className:"output-wrapper"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div",{className:"actions"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div",{className:"col left"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("button",{onClick:handleCopy,title:"Copy"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("i",{className:"icon copy"}),copyText)),react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("div",{className:"col right"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("button",{onClick:handleClearOutput,title:"Clear"},react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("i",{className:"icon reset"}),"Clear"))),react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(react_monaco_editor__WEBPACK_IMPORTED_MODULE_4___default.a,{language:"typescript",theme:"vs-dark",value:outputValue,options:{readOnly:!0,automaticLayout:!0,lineNumbers:"off",minimap:{enabled:!1},fontSize:10,folding:!1}}))),react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement("textarea",{readOnly:!0,className:"no-visible",ref:function(n){n&&(textareaRef=n)},value:outputValue}),isModalOpen&&react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(components_Modals__WEBPACK_IMPORTED_MODULE_5__.b,{onClose:toggleModal}))}},375:function(n,e,r){"use strict";r.d(e,"a",(function(){return l}));var t=r(33),a=r.n(t),i=r(68),o=r(173),s=r(100),c=r(92);function l(n,e,r){return u.apply(this,arguments)}function u(){return(u=Object(i.a)(a.a.mark((function n(e,r,t){return a.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:n.t0=e,n.next=n.t0===c.a.WEB3?3:n.t0===c.a.ETHERS?7:11;break;case 3:return n.next=5,Object(s.e)();case 5:return window.web3=n.sent,n.abrupt("break",12);case 7:return window.ethers=o.ethers,window.provider=new o.ethers.providers.Web3Provider(window.ethereum),Object.keys(o.ethers).forEach((function(n){window[n]=o.ethers[n]})),n.abrupt("break",12);case 11:return n.abrupt("break",12);case 12:r&&Object.keys(r).filter((function(n){return r[n].instance})).forEach((function(n){var e=r[n];delete window[e.name]})),t&&Object.keys(t).filter((function(n){return t[n].instance})).forEach((function(n){var e=t[n];window[e.name]=e.instance}));case 14:case"end":return n.stop()}}),n)})))).apply(this,arguments)}},377:function(n,e,r){n.exports=r(378)},378:function(n,e,r){"use strict";r.r(e);var t=r(14),a=r.n(t),i=r(371),o=r.n(i),s=r(202);r(788);o.a.render(a.a.createElement(s.a,null),document.getElementById("root"))},384:function(n,e,r){},538:function(n,e){},547:function(n,e){},564:function(n,e){},566:function(n,e){},580:function(n,e){},582:function(n,e){},654:function(n,e){},656:function(n,e){},72:function(n,e,r){"use strict";r.d(e,"i",(function(){return m})),r.d(e,"b",(function(){return b})),r.d(e,"g",(function(){return p})),r.d(e,"h",(function(){return _})),r.d(e,"a",(function(){return f})),r.d(e,"m",(function(){return v})),r.d(e,"f",(function(){return y})),r.d(e,"k",(function(){return h})),r.d(e,"d",(function(){return E})),r.d(e,"j",(function(){return P})),r.d(e,"c",(function(){return k})),r.d(e,"l",(function(){return B})),r.d(e,"e",(function(){return O}));var t=r(100),a=r(230),i=r(181),o=r(92),s="".concat("web3playground-","files"),c="".concat("web3playground-","network"),l="".concat("web3playground-","last-used-"),u="".concat(l,"contracts"),d="".concat(l,"code"),g="".concat(l,"library");function m(n){if(n.id||n.name){var e=b();if(!e.map((function(n){return n.id})).includes(n.id)){e.push(n);try{window.localStorage.setItem(s,JSON.stringify(e))}catch(r){console.warn(r.message)}}}else console.error("Could not save file")}function b(){var n=window.localStorage.getItem(s);return n?JSON.parse(n):[]}function p(n){var e=b().filter((function(e){return e.id!==n.id}));try{window.localStorage.setItem(s,JSON.stringify(e))}catch(r){console.warn(r.message)}}function _(n){for(var e=b(),r=0;r<e.length;r++)if(e[r].id===n.id){e[r].name=n.name;try{window.localStorage.setItem(s,JSON.stringify(e))}catch(t){console.warn(t.message)}return}}function f(n){return b().filter((function(e){return e.id===n}))[0]||Object(i.a)(n)}function v(n){try{window.localStorage.setItem(c,n.toString())}catch(e){console.warn(e.message)}}function y(){var n=window.localStorage.getItem(c);return n?Number(n):-1}function h(n){try{window.localStorage.setItem(u,JSON.stringify(n))}catch(r){console.warn(r.message)}var e=Object(t.c)();e&&v(e)}function E(){var n=window.localStorage.getItem(u);return n?JSON.parse(n):{}}function P(n){try{window.localStorage.setItem(d,n),Object(a.a)()}catch(e){console.warn(e.message)}}function k(){var n=window.localStorage.getItem(d);return n||null}function B(n){try{window.localStorage.setItem(g,n),Object(a.a)()}catch(e){console.warn(e.message)}}function O(){var n=window.localStorage.getItem(g);return n||o.a.WEB3}},782:function(n,e,r){},783:function(n,e,r){},784:function(n,e,r){},785:function(n,e,r){},786:function(n,e,r){},787:function(n,e,r){},788:function(n,e,r){},92:function(n,e,r){"use strict";var t;r.d(e,"a",(function(){return t})),function(n){n.WEB3="web3",n.ETHERS="ethers"}(t||(t={}))}},[[377,2,3]]]);
//# sourceMappingURL=main.b4989ba5.chunk.js.map