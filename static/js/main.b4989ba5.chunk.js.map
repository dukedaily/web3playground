{"version":3,"sources":["libs/web3.ts","libs/contract.ts","libs/utils.ts","libs/ipfs.ts","components/App/AppContext.tsx","components/Loader/index.ts","components/Loader/Loader.tsx","components/Editor/index.ts","components/Playground/index.ts","components/Playground/Playground.tsx","components/Files/Files.tsx","components/Files/index.ts","components/App/App.tsx","components/App/index.ts","libs/beforeUnload.ts","libs/device.ts","components/Modals/Modal.tsx","components/Modals/UploadModal/index.ts","components/Modals/UploadModal/UploadModal.tsx","components/Modals/RenameModal/index.ts","components/Modals/RenameModal/RenameModal.tsx","components/Modals/index.ts","components/Editor/editorTypes/web3EditorTypes.d.ts","components/Editor/editorTypes/ethersTypes.d.ts","components/Editor/editorTypes/ethersBignumberTypes.d.ts","components/Editor/editorTypes/web3DefaultScript.js","components/Editor/editorTypes/ethersDefaultScript.js","components/Editor/editorTypes/index.ts","components/Editor/Editor.tsx","libs/global.ts","index.tsx","libs/localstorage.ts","constants.ts"],"names":["web3","chainId","CHAINS","ETHEREUM_MAINNET","value","label","id","ETHEREUM_ROPSTEN","ETHEREUM_RINKEBY","ETHEREUM_GOERLI","ETHEREUM_KOVAN","BSC_MAINNET","BSC_TESTNET","MATIC_MAINNET","MATIC_MUMBAI","ethereum","window","connect","a","autoRefreshOnNetworkChange","enable","Web3","eth","net","getId","providers","HttpProvider","getWeb3Instance","getNetworkNameById","chain","Object","values","find","Number","getNetworkId","isEthereumChain","isMaticChain","isBSCChain","getAPIKey","console","warn","getAPI","network","useNetwork","useState","setNetwork","useEffect","handleNetworkChanged","networkId","saveLastUsed","saveLastUsedNetwork","on","then","off","EMPTY_SLOT","ZERO_ADDRESS","TOPICS_FOR_PROXYS","topic","indexed","dataIndex","SLOTS_FOR_PROXYS","getContract","address","library","toAddress","fetch","res","json","abi","result","buildContract","contract","LIB","WEB3","getContractWeb3","ETHERS","getContractEthers","Contract","JSON","parse","message","EthersContract","ethers","Web3Provider","getSigner","findABIForProxy","proxyAddress","api","data","length","event","pop","getAddressByTopic","getAddressByData","messge","getAddressByStorageSlot","getAddressByMinimalProxy","index","topics","slice","from","substr","storage","utils","isAddress","startFrom","indexOf","possibleAddress","typeContractMethods","editorTypes","contracts","keys","filter","key","instance","map","name","options","jsonInterface","method","inputs","type","forEach","input","join","typeWeb3ContractMethods","methodTypes","interface","fragments","constant","replace","typeEthersContractMethods","omit","object","k","reduce","acc","condition","timeoutPromise","promise","ms","Promise","resolve","reject","setTimeout","Error","IPFS_RESOLVER","PINATA_RESOLVER","upload","obj","getLastUsedNetwork","getLastUsedContracts","code","getLastUsedCode","getLastUsedLibrary","stringify","blob","Blob","FormData","append","Date","now","headers","pinata_api_key","pinata_secret_api_key","body","error","resolveHash","hash","resolver","normalizeIPFSHash","AppContext","createContext","refreshFiles","Loader","className","React","PureComponent","Editor","Playground","props","fileId","isMaximized","handleToggleMaximizeEditor","loading","setLoading","setContracts","setCode","setError","setLibrary","isInitialMount","useRef","currentNetwork","isLoading","handleLoading","useCallback","shouldLoad","getContractInstance","isProxy","implementationAddress","href","target","rel","loadContracts","lastUsedContracts","newContracts","i","reloadContracts","setPlaygroundByIPFS","lib","fillSelectedContract","elements","currentTarget","form","element","handleNameChange","preventDefault","newContract","editedContract","isVarNameInUse","prevValue","handleIsProxyChange","handleChangeLibrary","saveLastUsedLibrary","renderContract","placeholder","onChange","e","handleAddressChange","disabled","toString","handleABIChange","onClick","handleRemoveContract","checked","htmlFor","location","pathname","split","splice","lastUsedNetwork","useLayoutEffect","current","contractsToSave","saveLastUsedContracts","toLowerCase","initCode","onChangeSize","divs","Files","files","currentFile","handleFileSelected","useContext","isModalOpen","setIsModalOpen","fileToEdit","setFileToEdit","toggleModal","div","func","removeEventListener","file","ref","document","addEventListener","push","selectFile","removeFile","removeFileFromList","onClose","App","getFiles","setFiles","setIsMaximized","setCurrentFile","getFileFromHash","saveFile","Provider","undefined","pristineBeforeUnload","onbeforeunload","setBeforeUnload","restoreBeforeUnload","isIOS","navigator","userAgent","match","Modal","title","children","UploadModal","textareaRef","setIsLoading","setHash","copyText","setCopyText","handleUpload","IpfsHash","hashLink","origin","readOnly","textarea","range","createRange","selectNodeContents","selection","getSelection","removeAllRanges","addRange","setSelectionRange","select","execCommand","RenameModal","setName","renameFile","getEditorTypes","web3Types","ethersBigNumberTypes","concat","ethersTypes","getDefaultScript","web3DefaultScript","ethersDefaultScript","OUTPUT_HEADLINE","currentCode","defaultScript","isRunning","setIsRunning","output","setOutput","prevContracts","usePrevious","monacoRef","instanceWindowVars","injectGlobals","editorWillMount","monaco","languages","typescript","typescriptDefaults","addExtraLib","editorDidMount","editor","model","getModel","getModeId","addCommand","KeyMod","CtrlCmd","KeyCode","KEY_S","saveLastUsedCode","trigger","Enter","handleExecuteCode","Shift","KEY_E","cleanState","setOutputState","eval","stack","handleCodeChange","newValue","handleResetCode","handleCopy","handleClearOutput","outputValue","language","theme","automaticLayout","lineNumbers","minimap","enabled","fontSize","folding","ReactDOM","render","getElementById","KEY_FILES","KEY_NETWORK","KEY_LAST_USED","KEY_CONTRACTS","KEY_CODE","KEY_LIBRARY","saveFiles","savedFile","includes","localStorage","setItem","getItem"],"mappings":"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","file":"static/js/main.b4989ba5.chunk.js","sourcesContent":["import { useState, useEffect } from 'react'\nimport Web3 from 'web3'\nimport { HttpProvider } from 'web3-providers-http/types'\nimport { saveLastUsedNetwork } from './localstorage'\n\nexport interface EthereumWindow {\n  ethereum?: HttpProvider & {\n    enable?: () => Promise<string[]>\n    send: any\n    on: (eventName: string, callback: any) => void\n    off: (eventName: string, callback: any) => void\n    autoRefreshOnNetworkChange: boolean\n    networkVersion: number\n  }\n}\n\nexport const CHAINS = {\n  ETHEREUM_MAINNET: { value: 'mainnet', label: 'Ethereum Mainnet', id: 1 },\n  ETHEREUM_ROPSTEN: { value: 'ropsten', label: 'Ropsten Testnet', id: 3 },\n  ETHEREUM_RINKEBY: { value: 'rinkeby', label: 'Rinkeby Testnet', id: 4 },\n  ETHEREUM_GOERLI: { value: 'goerli', label: 'Goerli Testnet', id: 5 },\n  ETHEREUM_KOVAN: { value: 'kovan', label: 'Kovan Testnet', id: 42 },\n  BSC_MAINNET: { value: 'bsc', label: 'Binance Smart Chain Mainnet', id: 56 },\n  BSC_TESTNET: {\n    value: 'bsc-testnet',\n    label: 'Binance Smart Chain Testnet',\n    id: 97\n  },\n  MATIC_MAINNET: { value: 'matic', label: 'Matic Mainnet', id: 137 },\n  MATIC_MUMBAI: { value: 'mumbai', label: 'Matic Mumbai', id: 80001 }\n}\n\nconst { ethereum } = window as EthereumWindow\n\nlet web3: Web3\nlet chainId: number\n\nexport async function connect() {\n  if (web3 && chainId) {\n    return web3\n  }\n\n  if (ethereum) {\n    ethereum.autoRefreshOnNetworkChange = false\n    if (ethereum.enable) {\n      await ethereum.enable()\n    }\n    web3 = new Web3(ethereum)\n    chainId = await web3.eth.net.getId()\n  } else {\n    chainId = 0\n    web3 = new Web3(new Web3.providers.HttpProvider('https://localhost:8545'))\n  }\n\n  return web3\n}\n\nexport async function getWeb3Instance(): Promise<Web3> {\n  return connect()\n}\n\nexport function getChains() {\n  return Object.values(CHAINS)\n}\n\nexport function getNetworkNameById(id: number): string {\n  const chain = getChains().find(chain => Number(chain.id) === Number(id))\n\n  return chain ? chain.value : 'unknown'\n}\n\nexport function getNetworkName() {\n  return chainId ? getNetworkNameById(chainId) : ''\n}\n\nexport function getNetworkId() {\n  return chainId\n}\n\nfunction isEthereumChain() {\n  return (\n    chainId === CHAINS.ETHEREUM_MAINNET.id ||\n    chainId === CHAINS.ETHEREUM_ROPSTEN.id ||\n    chainId === CHAINS.ETHEREUM_KOVAN.id ||\n    chainId === CHAINS.ETHEREUM_GOERLI.id ||\n    chainId === CHAINS.ETHEREUM_RINKEBY.id\n  )\n}\n\nfunction isMaticChain() {\n  return (\n    chainId === CHAINS.MATIC_MAINNET.id || chainId === CHAINS.MATIC_MUMBAI.id\n  )\n}\n\nfunction isBSCChain() {\n  return chainId === CHAINS.BSC_MAINNET.id || chainId === CHAINS.BSC_TESTNET.id\n}\n\nexport function getAPIKey() {\n  if (isEthereumChain()) {\n    return '39MIMBN2J9SFTJW1RKQPYJI89BAPZEVJVD'\n  }\n  if (isBSCChain()) {\n    return 'XUB8PMY81UWB8TFVIN8A36SZUG1Q7H4ZD5'\n  }\n  if (isMaticChain()) {\n    return ''\n  }\n\n  console.warn(`Could not find any API Key for the chain: ${chainId}`)\n\n  return ''\n}\n\nexport function getAPI(): string {\n  if (isEthereumChain()) {\n    const network = getNetworkNameById(chainId)\n    return `https://api${network !== 'mainnet' ? `-${network}` : ''\n      }.etherscan.io/api`\n  }\n\n  if (isBSCChain()) {\n    return `https://api${chainId === CHAINS.BSC_TESTNET.id ? '-testnet' : ''\n      }.bscscan.com/api`\n  }\n\n  if (isMaticChain()) {\n    return `https://api${chainId === CHAINS.MATIC_MUMBAI.id ? '-testnet' : ''\n      }.polygonscan.com/api`\n  }\n\n  console.warn(`Could not find any API for the chain: ${chainId}`)\n\n  return ''\n}\n\nexport function useNetwork() {\n  const [network, setNetwork] = useState(getNetworkName())\n\n  useEffect(() => {\n    function handleNetworkChanged(networkId: number, saveLastUsed = true) {\n      chainId = networkId\n      setNetwork(getNetworkNameById(networkId))\n\n      if (saveLastUsed) {\n        saveLastUsedNetwork(networkId)\n      }\n    }\n\n    if (ethereum) {\n      ethereum.on('chainChanged', () => handleNetworkChanged)\n      ethereum.on('networkChanged', handleNetworkChanged)\n      getWeb3Instance().then(() => handleNetworkChanged(chainId, false))\n    }\n\n    return () => {\n      if (ethereum) {\n        ethereum.off('chainChanged', handleNetworkChanged)\n        ethereum.off('networkChanged', handleNetworkChanged)\n      }\n    }\n  }, [])\n\n  return network\n}\n","import Web3 from 'web3'\nimport { Contract } from 'web3-eth-contract/types'\nimport { AbiItem } from 'web3-utils'\nimport ethers, { Contract as EthersContract } from 'ethers'\n\nimport { getWeb3Instance, getAPI, getAPIKey } from './web3'\nimport { SelectedContracts, ABI } from 'components/Playground/types'\nimport { LIB } from '../constants'\n\nexport const EMPTY_SLOT =\n  '0x0000000000000000000000000000000000000000000000000000000000000000'\nexport const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000'\n\nexport const TOPICS_FOR_PROXYS = [\n  {\n    topic: '0xe74baeef5988edac1159d9177ca52f0f3d68f624a1996f77467eb3ebfb316537', // Upgrade(address,bytes)\n    indexed: 1\n  },\n  {\n    topic: '0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b', // Upgraded(address)\n    dataIndex: 1\n  },\n  {\n    topic: '0x4d72fe0577a3a3f7da968d7b892779dde102519c25527b29cf7054f245c791b9', // Aragon's Initialization\n    indexed: 2\n  }\n]\n\nexport const SLOTS_FOR_PROXYS = [\n  '0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3', // Zep\n  '0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc' // EIP 1967\n]\n\nexport async function getContract(\n  address: string,\n  library: LIB,\n  toAddress?: string\n): Promise<{\n  contract: Contract | EthersContract\n  abi: AbiItem | ethers.ethers.ContractInterface\n} | null> {\n  const res = await fetch(\n    `${getAPI()}?module=contract&apikey=${getAPIKey()}&action=getabi&address=${address}`\n  )\n  const abi = await res.json()\n\n  if (abi.result === 'Contract source code not verified') {\n    return null\n  }\n\n  const contract = await buildContract(\n    library,\n    abi.result,\n    toAddress || address\n  )\n  return contract ? { contract, abi: abi.result } : null\n}\n\nexport function buildContract(library: LIB, abi: ABI, address: string) {\n  switch (library) {\n    case LIB.WEB3:\n      return getContractWeb3(abi, address)\n    case LIB.ETHERS:\n      return getContractEthers(abi, address)\n    default: {\n      console.warn('Invalid Lib')\n      return null\n    }\n  }\n}\n\nexport async function getContractWeb3(\n  abi: any,\n  address: string\n): Promise<Contract | null> {\n  const web3 = await getWeb3Instance()\n  try {\n    return new web3.eth.Contract(JSON.parse(abi), address)\n  } catch (e) {\n    console.warn(e.message)\n    return null\n  }\n}\n\nexport async function getContractEthers(\n  abi: any,\n  address: string\n): Promise<EthersContract | null> {\n  try {\n    return new EthersContract(\n      address,\n      JSON.parse(abi),\n      // @ts-ignore\n      new ethers.providers.Web3Provider(window.ethereum).getSigner()\n    )\n  } catch (e) {\n    console.warn(e.message)\n    return null\n  }\n}\n\nexport async function findABIForProxy(\n  proxyAddress: string\n): Promise<string | undefined> {\n  const web3 = await getWeb3Instance()\n  const api = `${getAPI()}?module=logs&action=getLogs&apikey=${getAPIKey()}&fromBlock=0&toBlock=latest&limit=1&address=${proxyAddress}&topic0=`\n\n  let address\n  for (let { topic, indexed, dataIndex } of TOPICS_FOR_PROXYS) {\n    try {\n      const res = await fetch(`${api}${topic}`)\n      const data = await res.json()\n      if (data.result.length > 0 && typeof data.result !== 'string') {\n        const event = data.result.pop()\n        address = indexed\n          ? getAddressByTopic(event, indexed!)\n          : getAddressByData(event, dataIndex!)\n\n        if (address && address !== '0x' && address !== ZERO_ADDRESS) {\n          return address\n        }\n      }\n    } catch (e) {\n      console.warn(e.messge)\n    }\n  }\n\n  address = await getAddressByStorageSlot(web3, proxyAddress)\n\n  if (\n    !address ||\n    (address && (address === EMPTY_SLOT || address === ZERO_ADDRESS))\n  ) {\n    address = await getAddressByMinimalProxy(web3, proxyAddress)\n  }\n\n  return address\n}\n\nfunction getAddressByTopic(event: { topics: string[] }, index: number) {\n  return `0x${event.topics[index].slice(-40)}`\n}\n\nfunction getAddressByData(event: { data: string }, index: number) {\n  const from = 32 * (index - 1) + 24\n  return `0x${event.data.slice(2).substr(from, from + 40)}`\n}\n\nasync function getAddressByStorageSlot(\n  web3: Web3,\n  proxyAddress: string\n): Promise<string | undefined> {\n  for (const storage of SLOTS_FOR_PROXYS) {\n    try {\n      const res = await fetch(\n        `${getAPI()}?module=proxy&action=eth_getStorageAt&address=${proxyAddress}&apikey=${getAPIKey()}&position=${storage}&tag=latest`\n      )\n      const data = (await res.json()).result\n\n      let address\n      if (data && web3.utils.isAddress(data.slice(-40))) {\n        address = `0x${data.slice(-40)}`\n      }\n\n      if (address && address !== '0x' && address !== ZERO_ADDRESS) {\n        return address\n      }\n    } catch (e) {\n      // Do Nothing\n    }\n  }\n}\n\nexport async function getAddressByMinimalProxy(\n  web3: Web3,\n  proxyAddress: string\n): Promise<string | undefined> {\n  const res = await fetch(\n    `${getAPI()}?module=proxy&apikey=${getAPIKey()}&action=eth_getCode&address=${proxyAddress}`\n  )\n  const data = (await res.json()).result\n\n  let address\n  const startFrom = data.indexOf('0x36') !== -1 ? 22 : 24 // If it is minimal proxy EIP-1167, starts from 22 (363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3)\n  const possibleAddress = `0x${data.slice(startFrom, startFrom + 40)}`\n  if (data && web3.utils.isAddress(possibleAddress)) {\n    address = possibleAddress\n  }\n\n  return address\n}\n\nexport function sanitizeABI(abi: string) {\n  return abi\n    .trim()\n    .replace(/(\\r\\n|\\n|\\r)/gm, '')\n    .replace(/\\s+/g, '')\n    .replace(\n      /(\\w+:)|(\\w+ :)/g,\n      matchedStr => `\"${matchedStr.substring(0, matchedStr.length - 1)}\":`\n    )\n}\n\nexport function typeContractMethods(\n  editorTypes: string,\n  contracts: SelectedContracts,\n  library: LIB\n): string {\n  switch (library) {\n    case LIB.WEB3:\n      return typeWeb3ContractMethods(editorTypes, contracts)\n    case LIB.ETHERS:\n      return typeEthersContractMethods(editorTypes, contracts)\n    default:\n      return ''\n  }\n}\n\n// Replace `methods: any` to `{ methodName: (params: types) Promise<any>}`\nexport function typeWeb3ContractMethods(\n  editorTypes: string,\n  contracts: SelectedContracts\n) {\n  return (\n    editorTypes +\n    Object.keys(contracts)\n      .filter(key => contracts[key].instance)\n      .map(key => {\n        const contract = contracts[key].instance!\n        const contractTypes = `declare var ${contracts[key].name}: Contract & {\n  methods: {\n    ${contract.options.jsonInterface\n            .map((method: any) => {\n              let inputs = ''\n\n              if (!method.inputs || method.type === 'constructor') {\n                return ''\n              }\n\n              method.inputs.forEach((input: any, index: number) => {\n                if (index > 0) {\n                  inputs += ', '\n                }\n\n                inputs += input.name\n                  ? input.name\n                  : method.inputs.length > 1\n                    ? `${input.type}_${index}`\n                    : input.type\n\n                if (input.type.indexOf('int') !== -1) {\n                  inputs += ': number | string'\n                } else {\n                  inputs += ': string'\n                }\n\n                if (input.type.indexOf('[]') !== -1) {\n                  inputs += `[]`\n                }\n              })\n\n              return `${method.name}: (${inputs}) => any`\n            })\n            .join('\\n')}\n  }`\n\n        return contractTypes\n      })\n      .join('\\n')\n  )\n}\n\n// Replace `methods: any` to `{ methodName: (params: types) Promise<any>}`\nexport function typeEthersContractMethods(\n  editorTypes: string,\n  contracts: SelectedContracts\n) {\n  return (\n    editorTypes +\n    Object.keys(contracts)\n      .filter(key => contracts[key].instance)\n      .map(key => {\n        const contract: EthersContract = (contracts[key]\n          .instance as EthersContract)!\n\n        const methodTypes = contract.interface.fragments\n          .map((method: any) => {\n            let inputs = ''\n\n            if (!method.inputs || method.type === 'constructor') {\n              return ''\n            }\n\n            method.inputs.forEach((input: any, index: number) => {\n              if (index > 0) {\n                inputs += ', '\n              }\n\n              inputs += input.name\n                ? input.name\n                : method.inputs.length > 1\n                  ? `${input.type}_${index}`\n                  : input.type\n\n              if (input.type.indexOf('int') !== -1) {\n                inputs += ': number | string'\n              } else {\n                inputs += ': string'\n              }\n\n              if (input.type.indexOf('[]') !== -1) {\n                inputs += `[]`\n              }\n            })\n\n            // @TODO: with outputs\n            // let outputs = ''\n            // method.outputs.forEach((input: any, index: number) => {\n            //   if (index > 0) {\n            //     outputs += ', '\n            //   }\n\n            //   outputs += input.name\n            //     ? input.name\n            //     : method.outputs.length > 1\n            //       ? `${input.type}_${index}`\n            //       : input.type\n\n            //   if (input.type.indexOf('int') !== -1) {\n            //     outputs += ': number | string'\n            //   } else {\n            //     outputs += ': string'\n            //   }\n\n            //   if (input.type.indexOf('[]') !== -1) {\n            //     outputs += `[]`\n            //   }\n            // })\n\n            // return `${method.name}: (${inputs}) => ${method.constant ? `Promise<${outputs}>` : '____MethodResult'}`\n\n            return `${method.name}: (${inputs}) => ${method.constant ? '____any' : '____MethodResult'\n              }`\n          })\n          .join('\\n')\n\n        const contractTypes = `declare var ${contracts[key].name}: Contract & {\n      readonly functions: {\n        ${methodTypes\n            .replace(/____MethodResult/g, 'Promise<ContractTransaction>')\n            .replace(/____any/g, 'Promise<any>')}\n      }\n      readonly callStatic: {\n        ${methodTypes\n            .replace(/____MethodResult/g, 'Promise<ContractTransaction>')\n            .replace(/____any/g, 'Promise<any>')}\n      }\n      readonly estimateGas: {\n        ${methodTypes\n            .replace(/____MethodResult/g, 'Promise<BigNumber>')\n            .replace(/____any/g, 'Promise<BigNumber>')}\n      }\n      readonly populateTransaction: {\n        ${methodTypes\n            .replace(/____MethodResult/g, 'Promise<PopulatedTransaction>')\n            .replace(/____any/g, 'Promise<PopulatedTransaction>')}\n      }\n      readonly filters: {\n        ${methodTypes\n            .replace(/____MethodResult/g, '(...args: Array<any>) => EventFilter')\n            .replace(/____any/g, '(...args: Array<any>) => EventFilter')}\n      }\n      ${methodTypes\n            .replace(/____MethodResult/g, 'Promise<ContractTransaction>')\n            .replace(/____any/g, 'Promise<any>')}\n    }`\n\n        return contractTypes\n      })\n      .join('\\n')\n  )\n}\n","export function omit<T>(object: T, key?: string): T {\n  return key ? Object.keys(object)\n    .filter(k => k !== key)\n    .reduce(\n      (acc, k) => ({\n        ...acc,\n        [k]: object[k]\n      }),\n      {} as T\n    ) : object\n}\n\nexport function filter<T>(object: T, condition: (p: any) => boolean): T {\n  return Object.keys(object)\n    .filter(k => condition(object[k]))\n    .reduce(\n      (acc, k) => ({\n        ...acc,\n        [k]: object[k]\n      }),\n      {} as T\n    )\n}\n\nexport async function timeoutPromise<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      reject(new Error(\"timeout\"))\n    }, ms)\n    promise.then(resolve, reject)\n  })\n}","import {\n  getLastUsedNetwork,\n  getLastUsedCode,\n  getLastUsedContracts,\n  getLastUsedLibrary\n} from 'libs/localstorage'\nimport { timeoutPromise } from 'libs/utils'\nimport { File } from 'components/Files/types'\n\nconst IPFS_RESOLVER = 'https://ipfs.io/ipfs/'\nconst PINATA_RESOLVER = 'https://gateway.pinata.cloud/ipfs/'\n\n// I know that I am exposing secret keys but it is in purpose!\nexport async function upload() {\n  // const pinataAPIKey = '41d9d533daec1ccef42a'\n  // const pinataSecretAPIKey = '1721c608c98314394260fb427e6f7ba6ace1e1876ebc4b645387f95bb77eacf0'\n\n  // const pinataAPIKey = process.env.pinataAPIKey || ''\n  // const pinataSecretAPIKey = process.env.pinataAPIKey || ''\n\n  const pinataAPIKey = 'b0450654b560b1db47cb'\n  const pinataSecretAPIKey =\n    '4afc2d10236c41d02a1466c451e8fa482b00eb86a0eee317fae85cb49c2680e3'\n\n  const url = `https://api.pinata.cloud/pinning/pinFileToIPFS`\n\n  const obj = {\n    network: getLastUsedNetwork(),\n    contracts: getLastUsedContracts(),\n    code: getLastUsedCode(),\n    library: getLastUsedLibrary()\n  }\n\n  const json = JSON.stringify(obj)\n  const blob = new Blob([json], {\n    type: 'application/json'\n  })\n\n  const data = new FormData()\n  data.append('file', blob, `web3playground-${Date.now()}.json`)\n\n  try {\n    const res = await fetch(url, {\n      method: 'POST',\n      headers: {\n        pinata_api_key: pinataAPIKey,\n        pinata_secret_api_key: pinataSecretAPIKey\n      },\n      body: data\n    })\n\n    return res.json()\n  } catch (e) {\n    return { error: e.message }\n  }\n}\n\n// Try pinata resolver first, then IPFS https resolver, then kaput!\nexport async function resolveHash(hash: string) {\n  let data\n  try {\n    data = await resolve(hash, PINATA_RESOLVER)\n  } catch (e) {\n    if (e.message === 'timeout') {\n      data = await resolve(hash, IPFS_RESOLVER)\n    } else {\n      throw e\n    }\n  }\n  return data\n}\n\nasync function resolve(hash: string, resolver: string) {\n  const res = await timeoutPromise(fetch(`${resolver}${hash}`), 30000)\n  return res.json()\n}\n\nexport function normalizeIPFSHash(hash: string): File {\n  return { name: hash, id: hash }\n}\n","import { createContext } from 'react'\n\nimport { File } from 'components/Files/types'\n\ntype AppContext = {\n  refreshFiles: (fileId?: File) => void\n}\n\nexport const AppContext = createContext<AppContext>({\n  refreshFiles: () => {}\n})\n","import Loader from './Loader'\n\nexport default Loader\n","import React from 'react'\n\nimport './Loader.css'\n\nexport default class Loader extends React.PureComponent {\n  render() {\n    return (\n      <div className=\"lds-spinner\">\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n        <div></div>\n      </div>\n    )\n  }\n}\n","import Editor from './Editor'\n\nexport default Editor\n","import Playground from './Playground'\n\nexport default Playground","import React, {\n  useState,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useCallback\n} from 'react'\n\nimport Loader from 'components/Loader'\nimport Editor from 'components/Editor'\nimport { findABIForProxy, getContract, buildContract } from 'libs/contract'\nimport {\n  saveLastUsedContracts,\n  getLastUsedContracts,\n  getLastUsedNetwork,\n  saveLastUsedLibrary,\n  getLastUsedLibrary\n} from 'libs/localstorage'\nimport { omit, filter } from 'libs/utils'\nimport { resolveHash } from 'libs/ipfs'\nimport { useNetwork, getNetworkNameById } from 'libs/web3'\nimport { LIB } from '../../constants'\nimport {\n  Props,\n  SelectedContracts,\n  SelectedContract,\n  SelectedContractError,\n  ABI\n} from './types'\n\nimport './Playground.css'\n\nexport default function Playground(props: Props) {\n  const { fileId, isMaximized, handleToggleMaximizeEditor } = props\n\n  const [loading, setLoading] = useState(0)\n  const [contracts, setContracts] = useState<SelectedContracts>({})\n  const [code, setCode] = useState(null)\n  const [network, setNetwork] = useState<string>()\n  const [error, setError] = useState<{ message: string; hash: string }>()\n  const [library, setLibrary] = useState(getLastUsedLibrary())\n  const isInitialMount = useRef(true)\n\n  const currentNetwork = useNetwork()\n  const isLoading = !!loading\n\n  const handleLoading = useCallback((shouldLoad: boolean) => {\n    setLoading(loading => (shouldLoad ? loading + 1 : loading - 1))\n  }, [])\n\n  const getContractInstance = useCallback(\n    async (contract: SelectedContract, library: LIB) => {\n      handleLoading(true)\n\n      let instance = null\n      let error: SelectedContractError = null\n\n      try {\n      if (contract.isProxy) {\n        const implementationAddress = await findABIForProxy(contract.address)\n        if (implementationAddress) {\n          instance = await getContract(\n            implementationAddress,\n            library,\n            contract.address\n          )\n        }\n      } else {\n        instance = await getContract(contract.address, library)\n      }\n    } catch (e) {\n      console.warn(e.message)\n    }\n\n      if (!instance) {\n        error = (\n          <p>\n            {'No implementation found. Please contact me'}\n            <a\n              href=\"https://twitter.com/nachomazzara\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              {'@nachomazzara'}\n            </a>\n          </p>\n        )\n      }\n\n      handleLoading(false)\n\n      return { instance, error }\n    },\n    [handleLoading]\n  )\n\n  const loadContracts = useCallback(\n    async (lastUsedContracts: SelectedContract[], library: LIB) => {\n      const newContracts = {}\n      for (let i = 0; i < lastUsedContracts.length; i++) {\n        const contract = lastUsedContracts[i]\n        const { instance, error } = await getContractInstance(contract, library)\n\n        newContracts[contract.address] = {\n          ...contract,\n          abi: instance ? instance.abi : null,\n          instance: instance ? instance.contract : null,\n          error\n        }\n      }\n\n      setContracts(newContracts)\n    },\n    [getContractInstance]\n  )\n\n  const reloadContracts = useCallback(\n    async (library: LIB) => {\n      handleLoading(true)\n\n      const newContracts = {}\n      for (const address in contracts) {\n        const contract = contracts[address]\n        const instance = await buildContract(library, contract.abi, address)\n\n        newContracts[contract.address] = {\n          ...contract,\n          instance,\n          error: null\n        }\n      }\n\n      setContracts(newContracts)\n      handleLoading(false)\n    },\n    [contracts, handleLoading]\n  )\n\n  const setPlaygroundByIPFS = useCallback(\n    async (hash: string) => {\n      handleLoading(true)\n      try {\n        const data = await resolveHash(hash)\n        const lib = data.library || LIB.WEB3\n\n        setLibrary(lib)\n\n        if (data.contracts) {\n          await loadContracts(data.contracts, lib)\n        }\n\n        if (data.network) {\n          setNetwork(getNetworkNameById(data.network))\n        }\n\n        if (data.code) {\n          setCode(data.code)\n        }\n      } catch (e) {\n        setError({ message: e.message, hash })\n      }\n\n      handleLoading(false)\n    },\n    [loadContracts, handleLoading]\n  )\n\n  useEffect(() => {\n    if (currentNetwork) {\n      const paths = window.location.pathname.split('/').splice(1)\n      const hash = paths[0]\n      if (hash) {\n        setPlaygroundByIPFS(hash)\n      } else {\n        const lastUsedContracts = getLastUsedContracts()\n        const lastUsedNetwork = getLastUsedNetwork()\n\n        if (lastUsedContracts) {\n          setNetwork(getNetworkNameById(lastUsedNetwork))\n          loadContracts(lastUsedContracts as SelectedContract[], library)\n        }\n      }\n    }\n    // I'm sorry but library is a weird thing and I don't have more time. I failed you\n    // eslint-disable-next-line\n  }, [currentNetwork, loadContracts, setPlaygroundByIPFS])\n\n  useEffect(() => {\n    if (fileId) {\n      setPlaygroundByIPFS(fileId)\n    }\n  }, [fileId, setPlaygroundByIPFS])\n\n  useLayoutEffect(() => {\n    if (isInitialMount.current) {\n      isInitialMount.current = false\n    } else {\n      const contractsToSave = Object.keys(contracts).map(key => ({\n        name: contracts[key].name,\n        address: contracts[key].address,\n        isProxy: contracts[key].isProxy\n      }))\n      saveLastUsedContracts(contractsToSave)\n    }\n  }, [contracts])\n\n  function fillSelectedContract(event: React.FormEvent<any>) {\n    const elements = event.currentTarget.form\n    const contract = {}\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i]\n      contract[element.name] = element.value\n    }\n\n    return contract as SelectedContract\n  }\n\n  function isVarNameInUse(contracts: SelectedContracts, name: string): boolean {\n    return !!Object.keys(contracts).find(key => contracts[key].name === name)\n  }\n\n  function handleNameChange(event: React.FormEvent<any>) {\n    event.preventDefault()\n\n    const newContract = fillSelectedContract(event)\n    const editedContract = contracts[newContract.address]\n\n    if (editedContract) {\n      const name = event.currentTarget.value.replace(/\\s/g, '')\n      let error = null\n      if (isVarNameInUse(omit(contracts, editedContract.address), name)) {\n        error = <p>{`Variable name \"${name}\" is already in use`}</p>\n      }\n      setContracts({\n        ...contracts,\n        [editedContract.address]: {\n          ...editedContract,\n          name,\n          error\n        }\n      })\n    }\n  }\n\n  async function handleAddressChange(\n    event: React.FormEvent<any>,\n    prevValue?: string\n  ) {\n    event.preventDefault()\n\n    if (event.currentTarget.value.length) {\n      const newContract = fillSelectedContract(event)\n      const editedContract = contracts[newContract.address]\n      if (!editedContract) {\n        newContract.isProxy = false\n      }\n\n      const { instance, error } = await getContractInstance(\n        newContract,\n        library\n      )\n\n      setContracts({\n        ...omit(contracts, prevValue),\n        [newContract.address]: {\n          ...newContract,\n          instance: instance ? instance.contract : null,\n          abi: instance ? instance.abi : [],\n          error\n        }\n      })\n    } else {\n      setContracts(omit(contracts, prevValue))\n    }\n  }\n\n  async function handleIsProxyChange(event: React.FormEvent<any>) {\n    event.preventDefault()\n\n    const newContract = fillSelectedContract(event)\n    const editedContract = contracts[newContract.address]\n\n    if (editedContract) {\n      newContract.isProxy = !editedContract.isProxy\n    } else {\n      newContract.isProxy = false\n    }\n\n    const { instance, error } = await getContractInstance(newContract, library)\n\n    setContracts({\n      ...contracts,\n      [newContract.address]: {\n        ...newContract,\n        instance: instance ? instance.contract : null,\n        abi: instance ? instance.abi : [],\n        error\n      }\n    })\n  }\n\n  async function handleABIChange(event: React.FormEvent<any>) {\n    event.preventDefault()\n\n    const newContract = fillSelectedContract(event)\n    newContract.isProxy = false\n\n    if (event.currentTarget.value.length) {\n      let instance = null\n      let error = null\n      let abi = event.currentTarget.value\n\n      try {\n        instance = await buildContract(library, abi, newContract.address)\n      } catch (e) {\n        error = e.message\n      }\n\n      setContracts({\n        ...contracts,\n        [newContract.address]: {\n          ...newContract,\n          abi,\n          instance,\n          error\n        }\n      })\n    } else {\n      const { instance, error } = await getContractInstance(\n        newContract,\n        library\n      )\n      setContracts({\n        ...contracts,\n        [newContract.address]: {\n          ...newContract,\n          instance: instance ? instance.contract : null,\n          abi: instance ? instance.abi : [],\n          error\n        }\n      })\n    }\n  }\n\n  function handleRemoveContract(address: string) {\n    setContracts(omit(contracts, address))\n  }\n\n  function handleChangeLibrary(library: LIB) {\n    handleLoading(true)\n\n    setLibrary(library)\n    saveLastUsedLibrary(library)\n\n    reloadContracts(library)\n\n    handleLoading(false)\n  }\n\n  function renderContract(contract?: SelectedContract) {\n    let address: string | undefined\n    let name: string | undefined\n    let error: SelectedContractError | undefined\n    let abi: ABI | undefined\n\n    if (contract) {\n      address = contract.address\n      name = contract.name\n      error = contract.error\n      abi = contract.abi\n    }\n\n    return (\n      <form key={address || Date.now()}>\n        <div>\n          <input\n            name=\"address\"\n            type=\"text\"\n            placeholder=\"contract address\"\n            value={address}\n            onChange={e => handleAddressChange(e, address)}\n          />\n          <input\n            name=\"name\"\n            type=\"text\"\n            placeholder=\"variable name\"\n            value={name}\n            disabled={!address}\n            onChange={handleNameChange}\n          />\n          <input\n            name=\"abi\"\n            type=\"text\"\n            placeholder=\"ABI (optional)\"\n            value={abi ? abi.toString() : ''}\n            onChange={e => handleABIChange(e)}\n          />\n          {address && (\n            <i\n              className=\"icon trash\"\n              onClick={() => handleRemoveContract(address!)}\n            />\n          )}\n        </div>\n        <div className=\"isProxy\">\n          <input\n            name=\"isProxy\"\n            type=\"checkbox\"\n            disabled={!address}\n            onChange={handleIsProxyChange}\n            checked={contract ? contract.isProxy : false}\n          />\n          <label htmlFor=\"checkbox\">\n            {'Upgradable contract using a proxy pattern'}{' '}\n            <a\n              target=\"_blank\"\n              href=\"https://github.com/nachomazzara/web3playground#which-proxy-implementations-are-supported\"\n              rel=\"noopener noreferrer\"\n            >\n              ?\n            </a>\n          </label>\n        </div>\n        {error && <div className=\"error\">{error}</div>}\n      </form>\n    )\n  }\n\n  return (\n    <div className={`Playground ${isMaximized ? ' maximized' : ''}`}>\n      {isLoading && <Loader />}\n      <div className=\"header\">\n        <div className=\"network\">\n          <p className={currentNetwork}>{currentNetwork}</p>\n          {currentNetwork && network && currentNetwork !== network && (\n            <p className=\"error\">\n              The snippet you are trying to use is set to be run on {network}.\n              Please change the network.\n            </p>\n          )}\n        </div>\n        <div className=\"title\">\n          <div>\n            <h1>{`${library.toLowerCase()} Playground`}</h1>\n            {library !== LIB.WEB3 && (\n              <button onClick={() => handleChangeLibrary(LIB.WEB3)}>\n                Switch to Web3\n              </button>\n            )}\n            {library !== LIB.ETHERS && (\n              <button onClick={() => handleChangeLibrary(LIB.ETHERS)}>\n                Switch to Ethers\n              </button>\n            )}\n          </div>\n          <div className=\"menu\">\n            <a\n              target=\"_blank\"\n              href=\"https://github.com/nachomazzara/web3playground#how-it-works\"\n              rel=\"noopener noreferrer\"\n            >\n              {'How it works 👨‍💻'}\n            </a>\n          </div>\n        </div>\n        {error && (\n          <p className=\"error ipfs-error\">{`Failed to load the code snippet under the hash ${error.hash}: ${error.message}`}</p>\n        )}\n        <h2>Contracts</h2>\n        {Object.keys(contracts).map(key => renderContract(contracts[key]))}\n        {renderContract()}\n      </div>\n      <Editor\n        contracts={filter(\n          contracts,\n          (contract: SelectedContract) => !contract.error\n        )}\n        initCode={code}\n        isMaximized={isMaximized}\n        onChangeSize={handleToggleMaximizeEditor}\n        library={library}\n        isLoading={isLoading && !!currentNetwork}\n      />\n    </div>\n  )\n}\n","import React, { useContext, useState, useEffect } from 'react'\n\nimport { AppContext } from 'components/App'\nimport { RenameModal } from 'components/Modals'\nimport { removeFile } from 'libs/localstorage'\nimport { Props, File } from './types'\n\nimport './Files.css'\n\nconst divs: { div: HTMLDivElement; func: (e: MouseEvent) => void }[] = []\n\nexport default function Files(props: Props) {\n  const { files, currentFile, handleFileSelected } = props\n  const { refreshFiles } = useContext(AppContext)\n  const [isModalOpen, setIsModalOpen] = useState(false)\n  const [fileToEdit, setFileToEdit] = useState(currentFile)\n\n  function removeFileFromList(file: File) {\n    removeFile(file)\n    refreshFiles()\n  }\n\n  function selectFile(file: File) {\n    handleFileSelected(file)\n  }\n\n  function toggleModal() {\n    setIsModalOpen(!isModalOpen)\n  }\n\n  useEffect(() => {\n    return function cleanup() {\n      divs.forEach(({ div, func }) =>\n        div.removeEventListener('contextmenu', func)\n      )\n    }\n  }, [])\n\n  return (\n    <div className=\"Files\">\n      <div className=\"files-wrapper\">\n        {files.map(file => (\n          <div\n            key={file.id}\n            className={`file ${\n              currentFile && currentFile.id === file.id ? 'active' : ''\n            }`}\n            ref={div => {\n              if (div && document.addEventListener) {\n                const func = (e: MouseEvent) => {\n                  setFileToEdit(file)\n                  toggleModal()\n                  e.preventDefault()\n                }\n                div.addEventListener('contextmenu', func, false)\n                divs.push({ div, func })\n              }\n            }}\n          >\n            <button className=\"name\" onClick={() => selectFile(file)}>\n              {file.name}\n            </button>\n            <button className=\"close\" onClick={() => removeFileFromList(file)}>\n              x\n            </button>\n          </div>\n        ))}\n      </div>\n      {isModalOpen && <RenameModal onClose={toggleModal} file={fileToEdit!} />}\n    </div>\n  )\n}\n","import Files from './Files'\n\nexport default Files","import React, { useState, useEffect, useCallback } from 'react'\n\nimport { AppContext } from './AppContext'\nimport Playground from 'components/Playground'\nimport Files from 'components/Files'\nimport { File } from 'components/Files/types'\nimport { saveFile, getFiles, getFileFromHash } from 'libs/localstorage'\n\nexport default function App() {\n  const [files, setFiles] = useState<File[]>(getFiles())\n  const [isMaximized, setIsMaximized] = useState(false)\n  const [currentFile, setCurrentFile] = useState<File>()\n\n  function selectFile(file: File) {\n    setCurrentFile(file)\n  }\n\n  const refreshFiles = useCallback((file?: File) => {\n    setFiles(getFiles())\n    if (file) {\n      setCurrentFile(file)\n    }\n  }, [])\n\n  // Component will mount\n  useEffect(() => {\n    const paths = window.location.pathname.split('/').splice(1)\n    const hash = paths[0]\n    if (hash) {\n      const file = getFileFromHash(hash)\n\n      setCurrentFile(file)\n      saveFile(file)\n      refreshFiles()\n    }\n  }, [refreshFiles])\n\n  function handleToggleMaximizeEditor() {\n    setIsMaximized(!isMaximized)\n  }\n\n  return (\n    <AppContext.Provider value={{ refreshFiles }}>\n      <div className={`${isMaximized ? 'maximized' : ''}`}>\n        <Files\n          files={files}\n          currentFile={currentFile}\n          handleFileSelected={selectFile}\n        />\n        <Playground\n          fileId={currentFile ? currentFile.id : undefined}\n          isMaximized={isMaximized}\n          handleToggleMaximizeEditor={handleToggleMaximizeEditor}\n        />\n      </div>\n    </AppContext.Provider>\n  )\n}\n","import App from './App'\nimport { AppContext } from './AppContext'\n\nexport {\n  App,\n  AppContext\n}","\nconst pristineBeforeUnload = window.onbeforeunload\n\n// Prevent the user to accidentally exit\nexport function setBeforeUnload() {\n  window.onbeforeunload = () => 'Are you sure you want to quit?'\n}\n\n// Restore default window behavior\nexport function restoreBeforeUnload() {\n  window.onbeforeunload = pristineBeforeUnload\n}","export function isIOS() {\n  return navigator.userAgent.match(/ipad|iphone/i)\n}","import React from 'react'\n\nimport { Props } from './types'\n\nimport './Modal.css'\n\nexport default function Modal(props: Props) {\n  const { onClose, className, title, children } = props\n\n  return (\n    <div className={`Modal ${className}`}>\n      <div className=\"modal-wrapper\">\n        <div className=\"modal-header\">\n          <button className=\"close\" onClick={onClose}></button>\n          <h3>{title}</h3>\n        </div>\n        <div className=\"modal-body\">{children}</div>\n      </div>\n    </div>\n  )\n}\n","import UploadModal from './UploadModal'\n\nexport default UploadModal\n","import React, { useState, useEffect, useCallback, useContext } from 'react'\n\nimport { isIOS } from 'libs/device'\nimport { upload, normalizeIPFSHash } from 'libs/ipfs'\nimport { saveFile } from 'libs/localstorage'\nimport Modal from '../Modal'\nimport { AppContext } from 'components/App'\nimport { Props } from './types'\n\nimport './UploadModal.css'\n\nexport default function UploadModal(props: Props) {\n  const { refreshFiles } = useContext(AppContext)\n  const [isLoading, setIsLoading] = useState(true)\n  const [hash, setHash] = useState<string | null>(null)\n  const [error, setError] = useState<string | null>(null)\n  const [copyText, setCopyText] = useState('Copy')\n  let textareaRef: HTMLTextAreaElement\n\n  function handleCopy() {\n    setCopyText('Copied')\n\n    if (isIOS()) {\n      const range = document.createRange()\n      range.selectNodeContents(textareaRef)\n      const selection = window.getSelection()\n      if (selection) {\n        selection.removeAllRanges()\n        selection.addRange(range)\n      }\n      textareaRef.setSelectionRange(0, 999999)\n    } else {\n      textareaRef.select()\n    }\n\n    document.execCommand('copy')\n\n    window.setTimeout(() => setCopyText('Copy'), 1000)\n  }\n\n  const handleUpload = useCallback(async () => {\n    setIsLoading(true)\n    const { IpfsHash, error } = await upload()\n    if (error) {\n      setHash(null)\n      setError(error)\n    } else {\n      setHash(IpfsHash)\n      const file = normalizeIPFSHash(IpfsHash!)\n      saveFile(file)\n      refreshFiles(file)\n      setError(null)\n    }\n    setIsLoading(false)\n  }, [refreshFiles])\n\n  useEffect(() => {\n    handleUpload()\n  }, [handleUpload])\n\n  const hashLink = `${window.location.origin}/${hash}`\n\n  return (\n    <Modal onClose={props.onClose} className=\"UploadModal\" title=\"Share\">\n      {isLoading && <p>Uploading...</p>}\n      {hash && (\n        <div>\n          <p>{hashLink}</p>\n          <textarea\n            readOnly={true}\n            className=\"no-visible\"\n            ref={textarea => {\n              if (textarea) {\n                textareaRef = textarea\n              }\n            }}\n            value={hashLink}\n          />\n          <button onClick={handleCopy}>{copyText}</button>\n        </div>\n      )}\n      {error && (\n        <div>\n          <p className=\"error\">{error}</p>\n          <button onClick={handleUpload}>Try again</button>\n        </div>\n      )}\n    </Modal>\n  )\n}\n","import RenameModal from './RenameModal'\n\nexport default RenameModal\n","import React, { useState, useContext } from 'react'\n\nimport { renameFile } from 'libs/localstorage'\nimport Modal from '../Modal'\nimport { AppContext } from 'components/App'\nimport { Props } from './types'\n\nimport './RenameModal.css'\n\nexport default function RenameModal(props: Props) {\n  const { file, onClose } = props\n  const { refreshFiles } = useContext(AppContext)\n  const [name, setName] = useState<string>(file.name)\n  const [error, setError] = useState<string | null>(null)\n\n  function handleSave() {\n    renameFile({ ...file, name })\n    refreshFiles()\n    onClose()\n    setError(null)\n  }\n\n  return (\n    <Modal onClose={onClose} className=\"RenameModal\" title=\"Rename\">\n      <div className=\"form\">\n        <input value={name} onChange={e => setName(e.target.value)} />\n        <button onClick={handleSave}>{'Submit'}</button>\n      </div>\n      {error && <p className=\"error\">{error}</p>}\n    </Modal>\n  )\n}\n","export { default as UploadModal } from './UploadModal'\nexport { default as RenameModal } from './RenameModal'\n","export default \"// This file is based of web3.js v1.2.2\\n\\ntype Endianness = 'le' | 'be';\\ntype IPrimeName = 'k256' | 'p224' | 'p192' | 'p25519';\\n\\ninterface MPrime {\\n  name: string;\\n  p: BN;\\n  n: number;\\n  k: BN;\\n}\\n\\ninterface ReductionContext {\\n  m: number;\\n  prime: MPrime;\\n  [key: string]: any;\\n}\\n\\ndeclare interface BN {\\n  constructor(\\n    number: number | string | number[] | Uint8Array | Buffer | BN,\\n    base?: number | 'hex',\\n    endian?: Endianness\\n  );\\n  constructor(\\n    number: number | string | number[] | Uint8Array | Buffer | BN,\\n    endian?: Endianness\\n  )\\n\\n  /**\\n   * @description  create a reduction context\\n   */\\n  red(reductionContext: BN | IPrimeName): ReductionContext;\\n\\n  /**\\n   * @description  create a reduction context  with the Montgomery trick.\\n   */\\n  mont(num: BN): ReductionContext;\\n\\n  /**\\n   * @description returns true if the supplied object is a BN.js instance\\n   */\\n  isBN(b: any): b is BN;\\n\\n  /**\\n   * @description returns the maximum of 2 BN instances.\\n   */\\n  max(left: BN, right: BN): BN;\\n\\n  /**\\n   * @description returns the minimum of 2 BN instances.\\n   */\\n  min(left: BN, right: BN): BN;\\n\\n  /**\\n   * @description  clone number\\n   */\\n  clone(): BN;\\n\\n  /**\\n   * @description  convert to base-string and pad with zeroes\\n   */\\n  toString(base?: number | 'hex', length?: number): string;\\n\\n  /**\\n   * @description convert to Javascript Number (limited to 53 bits)\\n   */\\n  toNumber(): number;\\n\\n  /**\\n   * @description convert to JSON compatible hex string (alias of toString(16))\\n   */\\n  toJSON(): string;\\n\\n  /**\\n   * @description  convert to byte Array, and optionally zero pad to length, throwing if already exceeding\\n   */\\n  toArray(endian?: Endianness, length?: number): number[];\\n\\n  /**\\n   * @description convert to an instance of `type`, which must behave like an Array\\n   */\\n  toArrayLike(\\n    ArrayType: typeof Buffer,\\n    endian?: Endianness,\\n    length?: number\\n  ): Buffer;\\n\\n  toArrayLike(\\n    ArrayType: any[],\\n    endian?: Endianness,\\n    length?: number\\n  ): any[];\\n\\n  /**\\n   * @description  convert to Node.js Buffer (if available). For compatibility with browserify and similar tools, use this instead: a.toArrayLike(Buffer, endian, length)\\n   */\\n  toBuffer(endian?: Endianness, length?: number): Buffer;\\n\\n  /**\\n   * @description get number of bits occupied\\n   */\\n  bitLength(): number;\\n\\n  /**\\n   * @description return number of less-significant consequent zero bits (example: 1010000 has 4 zero bits)\\n   */\\n  zeroBits(): number;\\n\\n  /**\\n   * @description return number of bytes occupied\\n   */\\n  byteLength(): number;\\n\\n  /**\\n   * @description  true if the number is negative\\n   */\\n  isNeg(): boolean;\\n\\n  /**\\n   * @description  check if value is even\\n   */\\n  isEven(): boolean;\\n\\n  /**\\n   * @description   check if value is odd\\n   */\\n  isOdd(): boolean;\\n\\n  /**\\n   * @description  check if value is zero\\n   */\\n  isZero(): boolean;\\n\\n  /**\\n   * @description compare numbers and return `-1 (a < b)`, `0 (a == b)`, or `1 (a > b)` depending on the comparison result\\n   */\\n  cmp(b: BN): -1 | 0 | 1;\\n\\n  /**\\n   * @description compare numbers and return `-1 (a < b)`, `0 (a == b)`, or `1 (a > b)` depending on the comparison result\\n   */\\n  ucmp(b: BN): -1 | 0 | 1;\\n\\n  /**\\n   * @description compare numbers and return `-1 (a < b)`, `0 (a == b)`, or `1 (a > b)` depending on the comparison result\\n   */\\n  cmpn(b: number): -1 | 0 | 1;\\n\\n  /**\\n   * @description a less than b\\n   */\\n  lt(b: BN): boolean;\\n\\n  /**\\n   * @description a less than b\\n   */\\n  ltn(b: number): boolean;\\n\\n  /**\\n   * @description a less than or equals b\\n   */\\n  lte(b: BN): boolean;\\n\\n  /**\\n   * @description a less than or equals b\\n   */\\n  lten(b: number): boolean;\\n\\n  /**\\n   * @description a greater than b\\n   */\\n  gt(b: BN): boolean;\\n\\n  /**\\n   * @description a greater than b\\n   */\\n  gtn(b: number): boolean;\\n\\n  /**\\n   * @description a greater than or equals b\\n   */\\n  gte(b: BN): boolean;\\n\\n  /**\\n   * @description a greater than or equals b\\n   */\\n  gten(b: number): boolean;\\n\\n  /**\\n   * @description a equals b\\n   */\\n  eq(b: BN): boolean;\\n\\n  /**\\n   * @description a equals b\\n   */\\n  eqn(b: number): boolean;\\n\\n  /**\\n   * @description convert to two's complement representation, where width is bit width\\n   */\\n  toTwos(width: number): BN;\\n\\n  /**\\n   * @description  convert from two's complement representation, where width is the bit width\\n   */\\n  fromTwos(width: number): BN;\\n\\n  /**\\n   * @description negate sign\\n   */\\n  neg(): BN;\\n\\n  /**\\n   * @description negate sign\\n   */\\n  ineg(): BN;\\n\\n  /**\\n   * @description absolute value\\n   */\\n  abs(): BN;\\n\\n  /**\\n   * @description absolute value\\n   */\\n  iabs(): BN;\\n\\n  /**\\n   * @description addition\\n   */\\n  add(b: BN): BN;\\n\\n  /**\\n   * @description  addition\\n   */\\n  iadd(b: BN): BN;\\n\\n  /**\\n   * @description addition\\n   */\\n  addn(b: number): BN;\\n\\n  /**\\n   * @description addition\\n   */\\n  iaddn(b: number): BN;\\n\\n  /**\\n   * @description subtraction\\n   */\\n  sub(b: BN): BN;\\n\\n  /**\\n   * @description subtraction\\n   */\\n  isub(b: BN): BN;\\n\\n  /**\\n   * @description subtraction\\n   */\\n  subn(b: number): BN;\\n\\n  /**\\n   * @description subtraction\\n   */\\n  isubn(b: number): BN;\\n\\n  /**\\n   * @description multiply\\n   */\\n  mul(b: BN): BN;\\n\\n  /**\\n   * @description multiply\\n   */\\n  imul(b: BN): BN;\\n\\n  /**\\n   * @description multiply\\n   */\\n  muln(b: number): BN;\\n\\n  /**\\n   * @description multiply\\n   */\\n  imuln(b: number): BN;\\n\\n  /**\\n   * @description square\\n   */\\n  sqr(): BN;\\n\\n  /**\\n   * @description square\\n   */\\n  isqr(): BN;\\n\\n  /**\\n   * @description raise `a` to the power of `b`\\n   */\\n  pow(b: BN): BN;\\n\\n  /**\\n   * @description divide\\n   */\\n  div(b: BN): BN;\\n\\n  /**\\n   * @description divide\\n   */\\n  divn(b: number): BN;\\n\\n  /**\\n   * @description divide\\n   */\\n  idivn(b: number): BN;\\n\\n  /**\\n   * @description reduct\\n   */\\n  mod(b: BN): BN;\\n\\n  /**\\n   * @description reduct\\n   */\\n  umod(b: BN): BN;\\n\\n  /**\\n   * @see API consistency https://github.com/indutny/bn.js/pull/130\\n   * @description reduct\\n   */\\n  modn(b: number): number;\\n\\n  /**\\n   * @description  rounded division\\n   */\\n  divRound(b: BN): BN;\\n\\n  /**\\n   * @description or\\n   */\\n  or(b: BN): BN;\\n\\n  /**\\n   * @description or\\n   */\\n  ior(b: BN): BN;\\n\\n  /**\\n   * @description or\\n   */\\n  uor(b: BN): BN;\\n\\n  /**\\n   * @description or\\n   */\\n  iuor(b: BN): BN;\\n\\n  /**\\n   * @description and\\n   */\\n  and(b: BN): BN;\\n\\n  /**\\n   * @description and\\n   */\\n  iand(b: BN): BN;\\n\\n  /**\\n   * @description and\\n   */\\n  uand(b: BN): BN;\\n\\n  /**\\n   * @description and\\n   */\\n  iuand(b: BN): BN;\\n\\n  /**\\n   * @description and (NOTE: `andln` is going to be replaced with `andn` in future)\\n   */\\n  andln(b: number): BN;\\n\\n  /**\\n   * @description xor\\n   */\\n  xor(b: BN): BN;\\n\\n  /**\\n   * @description xor\\n   */\\n  ixor(b: BN): BN;\\n\\n  /**\\n   * @description xor\\n   */\\n  uxor(b: BN): BN;\\n\\n  /**\\n   * @description xor\\n   */\\n  iuxor(b: BN): BN;\\n\\n  /**\\n   * @description set specified bit to 1\\n   */\\n  setn(b: number): BN;\\n\\n  /**\\n   * @description shift left\\n   */\\n  shln(b: number): BN;\\n\\n  /**\\n   * @description shift left\\n   */\\n  ishln(b: number): BN;\\n\\n  /**\\n   * @description shift left\\n   */\\n  ushln(b: number): BN;\\n\\n  /**\\n   * @description shift left\\n   */\\n  iushln(b: number): BN;\\n\\n  /**\\n   * @description shift right\\n   */\\n  shrn(b: number): BN;\\n\\n  /**\\n   * @description shift right (unimplemented https://github.com/indutny/bn.js/blob/master/lib/bn.js#L2086)\\n   */\\n  ishrn(b: number): BN;\\n\\n  /**\\n   * @description shift right\\n   */\\n  ushrn(b: number): BN;\\n  /**\\n   * @description shift right\\n   */\\n\\n  iushrn(b: number): BN;\\n  /**\\n   * @description  test if specified bit is set\\n   */\\n\\n  testn(b: number): boolean;\\n  /**\\n   * @description clear bits with indexes higher or equal to `b`\\n   */\\n\\n  maskn(b: number): BN;\\n  /**\\n   * @description clear bits with indexes higher or equal to `b`\\n   */\\n\\n  imaskn(b: number): BN;\\n  /**\\n   * @description add `1 << b` to the number\\n   */\\n  bincn(b: number): BN;\\n\\n  /**\\n   * @description not (for the width specified by `w`)\\n   */\\n  notn(w: number): BN;\\n\\n  /**\\n   * @description not (for the width specified by `w`)\\n   */\\n  inotn(w: number): BN;\\n\\n  /**\\n   * @description GCD\\n   */\\n  gcd(b: BN): BN;\\n\\n  /**\\n   * @description Extended GCD results `({ a: ..., b: ..., gcd: ... })`\\n   */\\n  egcd(b: BN): { a: BN; b: BN; gcd: BN };\\n\\n  /**\\n   * @description inverse `a` modulo `b`\\n   */\\n  invm(b: BN): BN;\\n\\n  /**\\n   * @description Convert number to red\\n   */\\n  toRed(reductionContext: ReductionContext): RedBN;\\n}\\n\\n/**\\n * Big-Number interface  with additionnal methods that are using modular\\n * operation.\\n */\\ndeclare interface RedBN extends BN {\\n  /**\\n   * @description Convert back a number using a reduction context\\n   */\\n  fromRed(): BN;\\n\\n  /**\\n   * @description modular addition\\n   */\\n  redAdd(b: BN): RedBN;\\n\\n  /**\\n   * @description in-place modular addition\\n   */\\n  redIAdd(b: BN): RedBN;\\n\\n  /**\\n   * @description modular subtraction\\n   */\\n  redSub(b: BN): RedBN;\\n\\n  /**\\n   * @description in-place modular subtraction\\n   */\\n  redISub(b: BN): RedBN;\\n\\n  /**\\n   * @description modular shift left\\n   */\\n  redShl(num: number): RedBN;\\n\\n  /**\\n   * @description modular multiplication\\n   */\\n  redMul(b: BN): RedBN;\\n\\n  /**\\n   * @description in-place modular multiplication\\n   */\\n  redIMul(b: BN): RedBN;\\n\\n  /**\\n   * @description modular square\\n   */\\n  redSqr(): RedBN;\\n\\n  /**\\n   * @description in-place modular square\\n   */\\n  redISqr(): RedBN;\\n\\n  /**\\n   * @description modular square root\\n   */\\n  redSqrt(): RedBN;\\n\\n  /**\\n   * @description modular inverse of the number\\n   */\\n  redInvm(): RedBN;\\n\\n  /**\\n   * @description modular negation\\n   */\\n  redNeg(): RedBN;\\n\\n  /**\\n   * @description modular exponentiation\\n   */\\n  redPow(b: BN): RedBN;\\n}\\n\\ndeclare interface SignedTransaction {\\n  messageHash?: string;\\n  r: string;\\n  s: string;\\n  v: string;\\n  rawTransaction?: string;\\n  transactionHash?: string;\\n}\\n\\ndeclare interface Extension {\\n  property?: string,\\n  methods: any[]\\n}\\n\\ndeclare interface Providers {\\n  HttpProvider: any;\\n  WebsocketProvider: new (\\n    host: string,\\n    options?: any\\n  ) => any;\\n  IpcProvider: new (path: string, net: any) => IpcProvider;\\n}\\n\\ndeclare interface PromiEvent<T> extends Promise<T> {\\n  once(\\n    type: 'transactionHash',\\n    handler: (receipt: string) => void\\n  ): PromiEvent<T>;\\n\\n  once(\\n    type: 'receipt',\\n    handler: (receipt: TransactionReceipt) => void\\n  ): PromiEvent<T>;\\n\\n  once(\\n    type: 'confirmation',\\n    handler: (confNumber: number, receipt: TransactionReceipt) => void\\n  ): PromiEvent<T>;\\n\\n  once(type: 'error', handler: (error: Error) => void): PromiEvent<T>;\\n\\n  once(\\n    type: 'error' | 'confirmation' | 'receipt' | 'transactionHash',\\n    handler: (error: Error | TransactionReceipt | string) => void\\n  ): PromiEvent<T>;\\n\\n  on(\\n    type: 'transactionHash',\\n    handler: (receipt: string) => void\\n  ): PromiEvent<T>;\\n\\n  on(\\n    type: 'receipt',\\n    handler: (receipt: TransactionReceipt) => void\\n  ): PromiEvent<T>;\\n\\n  on(\\n    type: 'confirmation',\\n    handler: (confNumber: number, receipt: TransactionReceipt) => void\\n  ): PromiEvent<T>;\\n\\n  on(type: 'error', handler: (error: Error) => void): PromiEvent<T>;\\n\\n  on(\\n    type: 'error' | 'confirmation' | 'receipt' | 'transactionHash',\\n    handler: (error: Error | TransactionReceipt | string) => void\\n  ): PromiEvent<T>;\\n}\\n\\ndeclare interface Transaction {\\n  hash: string;\\n  nonce: number;\\n  blockHash: string | null;\\n  blockNumber: number | null;\\n  transactionIndex: number | null;\\n  from: string;\\n  to: string | null;\\n  value: string;\\n  gasPrice: string;\\n  gas: number;\\n  input: string;\\n}\\n\\ndeclare interface TransactionConfig {\\n  from?: string | number;\\n  to?: string;\\n  value?: number | string | BN;\\n  gas?: number | string;\\n  gasPrice?: number | string | BN;\\n  data?: string;\\n  nonce?: number;\\n  chainId?: number;\\n  common?: Common;\\n  chain?: string;\\n  hardfork?: string;\\n}\\n\\ndeclare type chain =\\n  | 'mainnet'\\n  | 'goerli'\\n  | 'kovan'\\n  | 'rinkeby'\\n  | 'ropsten';\\n\\ndeclare type hardfork =\\n  | 'chainstart'\\n  | 'homestead'\\n  | 'dao'\\n  | 'tangerineWhistle'\\n  | 'spuriousDragon'\\n  | 'byzantium'\\n  | 'constantinople'\\n  | 'petersburg'\\n  | 'istanbul';\\n\\ndeclare interface Common {\\n  customChain: CustomChainParams;\\n  baseChain?: chain;\\n  hardfork?: hardfork;\\n}\\n\\ndeclare interface CustomChainParams {\\n  name?: string;\\n  networkId: number;\\n  chainId: number;\\n}\\n\\ndeclare interface RLPEncodedTransaction {\\n  raw: string;\\n  tx: {\\n    nonce: string;\\n    gasPrice: string;\\n    gas: string;\\n    to: string;\\n    value: string;\\n    input: string;\\n    r: string;\\n    s: string;\\n    v: string;\\n    hash: string;\\n  };\\n}\\n\\ndeclare interface TransactionReceipt {\\n  status: boolean;\\n  transactionHash: string;\\n  transactionIndex: number;\\n  blockHash: string;\\n  blockNumber: number;\\n  from: string;\\n  to: string;\\n  contractAddress?: string;\\n  cumulativeGasUsed: number;\\n  gasUsed: number;\\n  logs: Log[];\\n  logsBloom: string;\\n  events?: {\\n    [eventName: string]: EventLog;\\n  };\\n}\\n\\ndeclare interface EventLog {\\n  event: string;\\n  address: string;\\n  returnValues: any;\\n  logIndex: number;\\n  transactionIndex: number;\\n  transactionHash: string;\\n  blockHash: string;\\n  blockNumber: number;\\n  raw?: { data: string; topics: any[] };\\n}\\n\\ndeclare interface Log {\\n  address: string;\\n  data: string;\\n  topics: Array<string | string[]>;\\n  logIndex: number;\\n  transactionIndex: number;\\n  transactionHash: string;\\n  blockHash: string;\\n  blockNumber: number;\\n}\\n\\n// had to move `web3-net` due to other modules in `1.x` not referencing\\n\\ndeclare interface NetworkBase {\\n  constructor(provider: provider, net?: any | null);\\n\\n  readonly givenProvider: any;\\n  readonly currentProvider: provider;\\n  BatchRequest: new () => BatchRequest;\\n  readonly providers: Providers;\\n\\n  setProvider(provider: provider): boolean;\\n\\n  extend(extension: Extension): any;\\n\\n  getNetworkType(\\n    callback?: (error: Error, returnValue: string) => void\\n  ): Promise<string>;\\n\\n  getId(callback?: (error: Error, id: number) => void): Promise<number>;\\n\\n  isListening(\\n    callback?: (error: Error, listening: boolean) => void\\n  ): Promise<boolean>;\\n\\n  getPeerCount(\\n    callback?: (error: Error, peerCount: number) => void\\n  ): Promise<number>;\\n}\\n\\n// had to move accounts from web3-eth-accounts due to other modules in 1.x not referencing\\n\\ndeclare interface AccountsBase {\\n  constructor(provider: provider, net?: any | null);\\n\\n  readonly givenProvider: any;\\n  readonly currentProvider: provider;\\n  BatchRequest: new () => BatchRequest;\\n  readonly providers: Providers;\\n\\n  setProvider(provider: provider): boolean;\\n\\n  extend(extension: Extension): any;\\n\\n  create(entropy?: string): Account;\\n\\n  privateKeyToAccount(privateKey: string): Account;\\n\\n  signTransaction(\\n    transactionConfig: TransactionConfig,\\n    privateKey: string,\\n    callback?: () => void\\n  ): Promise<SignedTransaction>;\\n\\n  recoverTransaction(signature: string): string;\\n\\n  hashMessage(message: string): string;\\n\\n  sign(data: string, privateKey: string): Sign;\\n\\n  recover(signatureObject: SignatureObject): string;\\n  recover(message: string, signature: string, preFixed?: boolean): string;\\n  recover(\\n    message: string,\\n    v: string,\\n    r: string,\\n    s: string,\\n    preFixed?: boolean\\n  ): string;\\n\\n  encrypt(privateKey: string, password: string): EncryptedKeystoreV3Json;\\n\\n  decrypt(keystoreJsonV3: EncryptedKeystoreV3Json, password: string): Account;\\n\\n  wallet: WalletBase;\\n}\\n\\ndeclare interface WalletBase {\\n  constructor(accounts: AccountsBase);\\n\\n  length: number;\\n  defaultKeyName: string;\\n\\n  [key: number]: Account;\\n\\n  create(numberOfAccounts: number, entropy?: string): WalletBase;\\n\\n  add(account: string | AddAccount): AddedAccount;\\n\\n  remove(account: string | number): boolean;\\n\\n  clear(): WalletBase;\\n\\n  encrypt(password: string): EncryptedKeystoreV3Json[];\\n\\n  decrypt(\\n    keystoreArray: EncryptedKeystoreV3Json[],\\n    password: string\\n  ): WalletBase;\\n\\n  save(password: string, keyName?: string): boolean;\\n\\n  load(password: string, keyName?: string): WalletBase;\\n}\\n\\ndeclare interface AddAccount {\\n  address: string;\\n  privateKey: string;\\n}\\n\\ndeclare interface AddedAccount extends Account {\\n  index: number;\\n}\\n\\ndeclare interface Account {\\n  address: string;\\n  privateKey: string;\\n  signTransaction: (\\n    transactionConfig: TransactionConfig,\\n    callback?: (signTransaction: SignedTransaction) => void\\n  ) => Promise<SignedTransaction>;\\n  sign: (data: string) => Sign;\\n  encrypt: (password: string) => EncryptedKeystoreV3Json;\\n}\\n\\ndeclare interface EncryptedKeystoreV3Json {\\n  version: number;\\n  id: string;\\n  address: string;\\n  crypto: {\\n    ciphertext: string;\\n    cipherparams: { iv: string };\\n    cipher: string;\\n    kdf: string;\\n    kdfparams: {\\n      dklen: number;\\n      salt: string;\\n      n: number;\\n      r: number;\\n      p: number;\\n    };\\n    mac: string;\\n  };\\n}\\n\\ndeclare interface Sign extends SignedTransaction {\\n  message: string;\\n  signature: string;\\n}\\n\\ndeclare interface SignatureObject {\\n  messageHash: string;\\n  r: string;\\n  s: string;\\n  v: string;\\n}\\n\\n// put all the `web3-provider` typings in here so we can get to them everywhere as this module does not exist in 1.x\\n\\ndeclare interface BatchRequest {\\n  constructor();\\n\\n  add(method: any): void;\\n\\n  execute(): void;\\n}\\n\\ndeclare interface HttpProvider {\\n  constructor(host: string, options?: any);\\n}\\n\\ndeclare interface IpcProvider {\\n  constructor(path: string, net: any);\\n}\\n\\ndeclare interface WebsocketProvider {\\n  constructor(host: string, options?: any);\\n\\n  isConnecting(): boolean;\\n}\\n\\ndeclare type provider =\\n  | HttpProvider\\n  | IpcProvider\\n  | WebsocketProvider\\n  | string\\n  | null;\\n\\n\\ndeclare type Unit =\\n  | 'noether'\\n  | 'wei'\\n  | 'kwei'\\n  | 'Kwei'\\n  | 'babbage'\\n  | 'femtoether'\\n  | 'mwei'\\n  | 'Mwei'\\n  | 'lovelace'\\n  | 'picoether'\\n  | 'gwei'\\n  | 'Gwei'\\n  | 'shannon'\\n  | 'nanoether'\\n  | 'nano'\\n  | 'szabo'\\n  | 'microether'\\n  | 'micro'\\n  | 'finney'\\n  | 'milliether'\\n  | 'milli'\\n  | 'ether'\\n  | 'kether'\\n  | 'grand'\\n  | 'mether'\\n  | 'gether'\\n  | 'tether';\\n\\ndeclare type Mixed =\\n  | string\\n  | number\\n  | BN\\n  | {\\n    type: string;\\n    value: string;\\n  }\\n  | {\\n    t: string;\\n    v: string | BN | number;\\n  }\\n  | boolean;\\n\\ndeclare type Hex = string | number;\\n\\n// utils types\\ndeclare function isBN(value: string | number): boolean;\\ndeclare function isBigNumber(value: BN): boolean;\\ndeclare function toBN(value: number | string): BN;\\ndeclare function toTwosComplement(value: number | string | BN): string;\\ndeclare function isAddress(address: string, chainId?: number): boolean;\\ndeclare function isHex(hex: Hex): boolean;\\ndeclare function isHexStrict(hex: Hex): boolean;\\ndeclare function asciiToHex(string: string, length?: number): string;\\ndeclare function hexToAscii(string: string): string;\\ndeclare function toAscii(string: string): string;\\ndeclare function bytesToHex(bytes: number[]): string;\\ndeclare function numberToHex(value: number | string | BN): string;\\ndeclare function checkAddressChecksum(address: string, chainId?: number): boolean;\\ndeclare function fromAscii(string: string): string;\\ndeclare function fromDecimal(value: string | number): string;\\ndeclare function fromUtf8(string: string): string;\\ndeclare function fromWei(value: string | BN, unit?: Unit): string;\\ndeclare function hexToBytes(hex: Hex): number[];\\ndeclare function hexToNumber(hex: Hex): number;\\ndeclare function hexToNumberString(hex: Hex): string;\\ndeclare function hexToString(hex: Hex): string;\\ndeclare function hexToUtf8(string: string): string;\\ndeclare function keccak256(value: string | BN): string;\\ndeclare function padLeft(value: string | number, characterAmount: number, sign?: string): string;\\ndeclare function leftPad(string: string | number, characterAmount: number, sign?: string): string;\\ndeclare function rightPad(string: string | number, characterAmount: number, sign?: string): string;\\ndeclare function padRight(string: string | number, characterAmount: number, sign?: string): string;\\ndeclare function sha3(value: string | BN): string;\\ndeclare function randomHex(bytesSize: number): string;\\ndeclare function utf8ToHex(string: string): string;\\ndeclare function stringToHex(string: string): string;\\ndeclare function toChecksumAddress(address: string, chainId?: number): string;\\ndeclare function toDecimal(hex: Hex): number;\\ndeclare function toHex(value: number | string | BN): string;\\ndeclare function toUtf8(string: string): string;\\ndeclare function toWei(val: BN, unit?: Unit): BN;\\ndeclare function toWei(val: string, unit?: Unit): string;\\ndeclare function isBloom(bloom: string): boolean;\\ndeclare function isInBloom(bloom: string, value: string | Uint8Array): boolean;\\ndeclare function isUserEthereumAddressInBloom(bloom: string, ethereumAddress: string): boolean;\\ndeclare function isContractAddressInBloom(bloom: string, contractAddress: string): boolean;\\ndeclare function isTopicInBloom(bloom: string, topic: string): boolean;\\ndeclare function isTopic(topic: string): boolean;\\ndeclare function jsonInterfaceMethodToString(abiItem: AbiItem): string;\\ndeclare function soliditySha3(...val: Mixed[]): string;\\ndeclare function getUnitValue(unit: Unit): string;\\ndeclare function unitMap(): Units;\\ndeclare function testAddress(bloom: string, address: string): boolean;\\ndeclare function testTopic(bloom: string, topic: string): boolean;\\ndeclare function getSignatureParameters(signature: string): { r: string; s: string; v: number };\\ndeclare function stripHexPrefix(str: string): string;\\n\\n// interfaces\\ndeclare interface Utils {\\n  isBN(value: string | number): boolean;\\n  isBigNumber(value: BN): boolean;\\n  toBN(value: number | string): BN;\\n  toTwosComplement(value: number | string | BN): string;\\n  isAddress(address: string, chainId?: number): boolean;\\n  isHex(hex: Hex): boolean;\\n  isHexStrict(hex: Hex): boolean;\\n  asciiToHex(string: string, length?: number): string;\\n  hexToAscii(string: string): string;\\n  toAscii(string: string): string;\\n  bytesToHex(bytes: number[]): string;\\n  numberToHex(value: number | string | BN): string;\\n  checkAddressChecksum(address: string, chainId?: number): boolean;\\n  fromAscii(string: string): string;\\n  fromDecimal(value: string | number): string;\\n  fromUtf8(string: string): string;\\n  fromWei(value: string | BN, unit?: Unit): string;\\n  hexToBytes(hex: Hex): number[];\\n  hexToNumber(hex: Hex): number;\\n  hexToNumberString(hex: Hex): string;\\n  hexToString(hex: Hex): string;\\n  hexToUtf8(string: string): string;\\n  keccak256(value: string | BN): string;\\n  padLeft(value: string | number, characterAmount: number, sign?: string): string;\\n  leftPad(string: string | number, characterAmount: number, sign?: string): string;\\n  rightPad(string: string | number, characterAmount: number, sign?: string): string;\\n  padRight(string: string | number, characterAmount: number, sign?: string): string;\\n  sha3(value: string | BN): string;\\n  randomHex(bytesSize: number): string;\\n  utf8ToHex(string: string): string;\\n  stringToHex(string: string): string;\\n  toChecksumAddress(address: string, chainId?: number): string;\\n  toDecimal(hex: Hex): number;\\n  toHex(value: number | string | BN): string;\\n  toUtf8(string: string): string;\\n  toWei(val: BN, unit?: Unit): BN;\\n  toWei(val: string, unit?: Unit): string;\\n  isBloom(bloom: string): boolean;\\n  isInBloom(bloom: string, value: string | Uint8Array): boolean;\\n  isUserEthereumAddressInBloom(bloom: string, ethereumAddress: string): boolean;\\n  isContractAddressInBloom(bloom: string, contractAddress: string): boolean;\\n  isTopicInBloom(bloom: string, topic: string): boolean;\\n  isTopic(topic: string): boolean;\\n  jsonInterfaceMethodToString(abiItem: AbiItem): string;\\n  soliditySha3(...val: Mixed[]): string;\\n  getUnitValue(unit: Unit): string;\\n  unitMap(): Units;\\n  testAddress(bloom: string, address: string): boolean;\\n  testTopic(bloom: string, topic: string): boolean;\\n  getSignatureParameters(signature: string): { r: string; s: string; v: number };\\n  stripHexPrefix(str: string): string;\\n}\\n\\ndeclare interface Units {\\n  noether: string;\\n  wei: string;\\n  kwei: string;\\n  Kwei: string;\\n  babbage: string;\\n  femtoether: string;\\n  mwei: string;\\n  Mwei: string;\\n  lovelace: string;\\n  picoether: string;\\n  gwei: string;\\n  Gwei: string;\\n  shannon: string;\\n  nanoether: string;\\n  nano: string;\\n  szabo: string;\\n  microether: string;\\n  micro: string;\\n  finney: string;\\n  milliether: string;\\n  milli: string;\\n  ether: string;\\n  kether: string;\\n  grand: string;\\n  mether: string;\\n  gether: string;\\n  tether: string;\\n}\\n\\ndeclare type AbiType = 'function' | 'constructor' | 'event' | 'fallback';\\ndeclare type StateMutabilityType = 'pure' | 'view' | 'nonpayable' | 'payable';\\n\\ndeclare interface AbiItem {\\n  anonymous?: boolean;\\n  constant?: boolean;\\n  inputs?: AbiInput[];\\n  name?: string;\\n  outputs?: AbiOutput[];\\n  payable?: boolean;\\n  stateMutability?: StateMutabilityType;\\n  type: AbiType;\\n}\\n\\ndeclare interface AbiInput {\\n  name: string;\\n  type: string;\\n  indexed?: boolean;\\n  components?: AbiInput[];\\n}\\n\\ndeclare interface AbiOutput {\\n  name: string;\\n  type: string;\\n  components?: AbiOutput[];\\n}\\n\\n\\ndeclare interface Subscription<T> {\\n  constructor(options: SubscriptionOptions);\\n\\n  id: string;\\n  options: SubscriptionOptions;\\n  callback: () => void;\\n  arguments: any;\\n\\n  subscribe(callback?: (error: Error, result: T) => void): Subscription<T>;\\n\\n  unsubscribe(\\n    callback?: (error: Error, result: boolean) => void\\n  ): Promise<undefined | boolean>;\\n\\n  on(type: 'data', handler: (data: T) => void): Subscription<T>;\\n\\n  on(type: 'changed', handler: (data: T) => void): Subscription<T>;\\n\\n  on(type: 'error', handler: (data: Error) => void): Subscription<T>;\\n}\\n\\ndeclare interface Subscriptions {\\n  constructor(options: SubscriptionsOptions);\\n\\n  name: string;\\n  type: string;\\n  subscriptions: SubscriptionsModel;\\n  readonly requestManager: any;\\n\\n  attachToObject(obj: any): void;\\n\\n  setRequestManager(requestManager: any): void;\\n\\n  buildCall(): () => any;\\n}\\n\\ndeclare interface SubscriptionOptions {\\n  subscription: string;\\n  type: string;\\n  requestManager: any;\\n}\\n\\ndeclare interface SubscriptionsOptions {\\n  name: string;\\n  type: string;\\n  subscriptions: SubscriptionsModel;\\n}\\n\\ndeclare interface SubscriptionsModel {\\n  [name: string]: SubscriptionModel;\\n}\\n\\ndeclare interface SubscriptionModel {\\n  subscriptionName: string;\\n  params: number;\\n  outputFormatter: () => void;\\n  inputFormatter: Array<() => void>;\\n  subscriptionHandler: () => void;\\n}\\n\\n\\ndeclare interface AbiCoder {\\n  encodeFunctionSignature(functionName: string | AbiItem): string;\\n\\n  encodeEventSignature(functionName: string | AbiItem): string;\\n\\n  encodeParameter(type: any, parameter: any): string;\\n\\n  encodeParameters(types: any[], paramaters: any[]): string;\\n\\n  encodeFunctionCall(abiItem: AbiItem, params: string[]): string;\\n\\n  decodeParameter(type: any, hex: string): { [key: string]: any };\\n\\n  decodeParameters(types: any[], hex: string): { [key: string]: any };\\n\\n  decodeLog(\\n    inputs: AbiInput[],\\n    hex: string,\\n    topics: string[]\\n  ): { [key: string]: string };\\n}\\n\\n\\ndeclare interface Ens {\\n  constructor(eth: any);\\n\\n  registry: Registry;\\n\\n  resolver(name: string): Promise<Contract>;\\n\\n  supportsInterface(\\n    name: string,\\n    interfaceId: string,\\n    callback?: (error: Error, supportsInterface: boolean) => void\\n  ): Promise<boolean>;\\n\\n  getAddress(\\n    name: string,\\n    callback?: (error: Error, address: string) => void\\n  ): Promise<string>;\\n\\n  setAddress(\\n    name: string,\\n    address: string,\\n    sendOptions: TransactionConfig,\\n    callback?: (error: Error, result: any) => void\\n  ): PromiEvent<any>;\\n\\n  getPubkey(\\n    name: string,\\n    callback?: (error: Error, result: { [x: string]: string }) => void\\n  ): Promise<{ [x: string]: string }>;\\n\\n  setPubkey(\\n    name: string,\\n    x: string,\\n    y: string,\\n    sendOptions: TransactionConfig,\\n    callback?: (error: Error, result: any) => void\\n  ): PromiEvent<any>;\\n\\n  getText(\\n    name: string,\\n    key: string,\\n    callback?: (error: Error, ensName: string) => void\\n  ): Promise<string>;\\n\\n  setText(\\n    name: string,\\n    key: string,\\n    value: string,\\n    sendOptions: TransactionConfig,\\n    callback?: (error: Error, result: any) => void\\n  ): PromiEvent<any>;\\n\\n  getContent(\\n    name: string,\\n    callback?: (error: Error, contentHash: string) => void\\n  ): Promise<string>;\\n\\n  setContent(\\n    name: string,\\n    hash: string,\\n    sendOptions: TransactionConfig,\\n    callback?: (error: Error, result: any) => void\\n  ): PromiEvent<any>;\\n\\n  getMultihash(\\n    name: string,\\n    callback?: (error: Error, multihash: string) => void\\n  ): Promise<string>;\\n\\n  setMultihash(\\n    name: string,\\n    hash: string,\\n    sendOptions: TransactionConfig,\\n    callback?: (error: Error, result: any) => void\\n  ): PromiEvent<any>;\\n\\n  getContenthash(\\n    name: string,\\n    callback?: (error: Error, contenthash: string) => void\\n  ): Promise<string>;\\n\\n  setContenthash(\\n    name: string,\\n    hash: string,\\n    sendOptions: TransactionConfig,\\n    callback?: (error: Error, result: any) => void\\n  ): PromiEvent<any>;\\n}\\n\\ndeclare interface Registry {\\n  constructor(ens: Ens);\\n\\n  ens: Ens;\\n\\n  contract: Contract | null;\\n\\n  owner(\\n    name: string,\\n    callback?: (error: Error, address: string) => void\\n  ): Promise<string>;\\n\\n  resolver(name: string): Promise<Contract>;\\n}\\n\\n\\ndeclare interface Accounts extends AccountsBase { }\\n\\ndeclare interface Wallet extends WalletBase { }\\n\\ndeclare interface Sign extends SignedTransaction {\\n  message: string;\\n  signature: string;\\n}\\n\\ndeclare interface SignatureObject {\\n  messageHash: string;\\n  r: string;\\n  s: string;\\n  v: string;\\n}\\n\\n\\ndeclare interface Personal {\\n  constructor(provider: provider);\\n\\n  newAccount(\\n    password: string,\\n    callback?: (error: Error, address: string) => void\\n  ): Promise<string>;\\n\\n  sign(\\n    dataToSign: string,\\n    address: string,\\n    password: string,\\n    callback?: (error: Error, signature: string) => void\\n  ): Promise<string>;\\n\\n  ecRecover(\\n    dataThatWasSigned: string,\\n    signature: string,\\n    callback?: (error: Error, address: string) => void\\n  ): Promise<string>;\\n\\n  signTransaction(\\n    transactionConfig: TransactionConfig,\\n    password: string,\\n    callback?: (\\n      error: Error,\\n      RLPEncodedTransaction: RLPEncodedTransaction\\n    ) => void\\n  ): Promise<RLPEncodedTransaction>;\\n\\n  sendTransaction(\\n    transactionConfig: TransactionConfig,\\n    password: string,\\n    callback?: (error: Error, transactionHash: string) => void\\n  ): Promise<string>;\\n\\n  unlockAccount(\\n    address: string,\\n    password: string,\\n    unlockDuration: number,\\n    callback?: (error: Error) => void\\n  ): Promise<boolean>;\\n\\n  lockAccount(\\n    address: string,\\n    callback?: (error: Error, success: boolean) => void\\n  ): Promise<boolean>;\\n\\n  getAccounts(\\n    callback?: (error: Error, accounts: string[]) => void\\n  ): Promise<string[]>;\\n\\n  importRawKey(\\n    privateKey: string,\\n    password: string,\\n    callback?: (error: Error, result: string) => void\\n  ): Promise<string>;\\n}\\n\\ndeclare interface Iban {\\n  constructor(\\n    iban: string\\n  )\\n\\n  toAddress(iban: string): string;\\n\\n  toIban(address: string): string;\\n\\n  fromAddress(address: string): Iban;\\n\\n  fromBban(bban: string): Iban;\\n\\n  createIndirect(options: IndirectOptions): Iban;\\n\\n  isValid(iban: string): boolean;\\n\\n  isValid(): boolean;\\n\\n  isDirect(): boolean;\\n\\n  isIndirect(): boolean;\\n\\n  checksum(): string;\\n\\n  institution(): string;\\n\\n  client(): string;\\n\\n  toAddress(): string;\\n\\n  toString(): string;\\n}\\n\\ndeclare interface IndirectOptions {\\n  institution: string;\\n  identifier: string;\\n}\\n\\ndeclare interface Eth {\\n  constructor(currentProvider: provider);\\n\\n  Contract: new (\\n    jsonInterface: AbiItem[] | AbiItem,\\n    address?: string,\\n    options?: ContractOptions\\n  ) => Contract;\\n  Iban: new (iban: string) => Iban;\\n  personal: Personal;\\n  accounts: Accounts;\\n  ens: Ens;\\n  abi: AbiCoder;\\n  net: any;\\n\\n  readonly givenProvider: any;\\n  defaultAccount: string | null;\\n  defaultBlock: string | number;\\n  defaultCommon: Common;\\n  defaultHardfork: hardfork;\\n  defaultChain: chain;\\n  transactionPollingTimeout: number;\\n  transactionConfirmationBlocks: number;\\n  transactionBlockTimeout: number;\\n  readonly currentProvider: provider;\\n  setProvider(provider: provider): boolean;\\n  BatchRequest: new () => BatchRequest;\\n  readonly providers: Providers;\\n  extend(extension: Extension): any;\\n\\n  clearSubscriptions(callback: (error: Error, result: boolean) => void): void;\\n\\n  subscribe(\\n    type: 'logs',\\n    options?: LogsOptions,\\n    callback?: (error: Error, log: Log) => void\\n  ): Subscription<Log>;\\n  subscribe(\\n    type: 'syncing',\\n    options?: null,\\n    callback?: (error: Error, result: Syncing) => void\\n  ): Subscription<Syncing>;\\n  subscribe(\\n    type: 'newBlockHeaders',\\n    options?: null,\\n    callback?: (error: Error, blockHeader: BlockHeader) => void\\n  ): Subscription<BlockHeader>;\\n  subscribe(\\n    type: 'pendingTransactions',\\n    options?: null,\\n    callback?: (error: Error, transactionHash: string) => void\\n  ): Subscription<string>;\\n  subscribe(\\n    type: 'pendingTransactions' | 'logs' | 'syncing' | 'newBlockHeaders',\\n    options?: null | LogsOptions,\\n    callback?: (\\n      error: Error,\\n      item: Log | Syncing | BlockHeader | string\\n    ) => void\\n  ): Subscription<Log | BlockHeader | Syncing | string>;\\n\\n  getProtocolVersion(\\n    callback?: (error: Error, protocolVersion: string) => void\\n  ): Promise<string>;\\n\\n  isSyncing(\\n    callback?: (error: Error, syncing: Syncing) => void\\n  ): Promise<Syncing | boolean>;\\n\\n  getCoinbase(\\n    callback?: (error: Error, coinbaseAddress: string) => void\\n  ): Promise<string>;\\n\\n  isMining(\\n    callback?: (error: Error, mining: boolean) => void\\n  ): Promise<boolean>;\\n\\n  getHashrate(\\n    callback?: (error: Error, hashes: number) => void\\n  ): Promise<number>;\\n\\n  getNodeInfo(\\n    callback?: (error: Error, version: string) => void\\n  ): Promise<string>;\\n\\n  getChainId(\\n    callback?: (error: Error, version: number) => void\\n  ): Promise<number>;\\n\\n  getGasPrice(\\n    callback?: (error: Error, gasPrice: string) => void\\n  ): Promise<string>;\\n\\n  getAccounts(\\n    callback?: (error: Error, accounts: string[]) => void\\n  ): Promise<string[]>;\\n\\n  getBlockNumber(\\n    callback?: (error: Error, blockNumber: number) => void\\n  ): Promise<number>;\\n\\n  getBalance(address: string): Promise<string>;\\n  getBalance(address: string, defaultBlock: string | number): Promise<string>;\\n  getBalance(\\n    address: string,\\n    callback?: (error: Error, balance: string) => void\\n  ): Promise<string>;\\n  getBalance(\\n    address: string,\\n    defaultBlock: string | number,\\n    callback?: (error: Error, balance: string) => void\\n  ): Promise<string>;\\n\\n  getStorageAt(address: string, position: number): Promise<string>;\\n  getStorageAt(\\n    address: string,\\n    position: number,\\n    defaultBlock: number | string\\n  ): Promise<string>;\\n  getStorageAt(\\n    address: string,\\n    position: number,\\n    callback?: (error: Error, storageAt: string) => void\\n  ): Promise<string>;\\n  getStorageAt(\\n    address: string,\\n    position: number,\\n    defaultBlock: number | string,\\n    callback?: (error: Error, storageAt: string) => void\\n  ): Promise<string>;\\n\\n  getCode(address: string): Promise<string>;\\n  getCode(address: string, defaultBlock: string | number): Promise<string>;\\n  getCode(\\n    address: string,\\n    callback?: (error: Error, code: string) => void\\n  ): Promise<string>;\\n  getCode(\\n    address: string,\\n    defaultBlock: string | number,\\n    callback?: (error: Error, code: string) => void\\n  ): Promise<string>;\\n\\n  getBlock(blockHashOrBlockNumber: string | number): Promise<Block>;\\n  getBlock(\\n    blockHashOrBlockNumber: string | number,\\n    returnTransactionObjects: boolean\\n  ): Promise<Block>;\\n  getBlock(\\n    blockHashOrBlockNumber: string | number,\\n    callback?: (error: Error, block: Block) => void\\n  ): Promise<Block>;\\n  getBlock(\\n    blockHashOrBlockNumber: string | number,\\n    returnTransactionObjects: boolean,\\n    callback?: (error: Error, block: Block) => void\\n  ): Promise<Block>;\\n\\n  getBlockTransactionCount(\\n    blockHashOrBlockNumber: string | number,\\n    callback?: (error: Error, numberOfTransactions: number) => void\\n  ): Promise<number>;\\n\\n  getUncle(\\n    blockHashOrBlockNumber: string | number,\\n    uncleIndex: number\\n  ): Promise<Block>;\\n  getUncle(\\n    blockHashOrBlockNumber: string | number,\\n    uncleIndex: number,\\n    returnTransactionObjects: boolean\\n  ): Promise<Block>;\\n  getUncle(\\n    blockHashOrBlockNumber: string | number,\\n    uncleIndex: number,\\n    callback?: (error: Error, uncle: any) => void\\n  ): Promise<Block>;\\n  getUncle(\\n    blockHashOrBlockNumber: string | number,\\n    uncleIndex: number,\\n    returnTransactionObjects: boolean,\\n    callback?: (error: Error, uncle: any) => void\\n  ): Promise<Block>;\\n\\n  getTransaction(\\n    transactionHash: string,\\n    callback?: (error: Error, transaction: Transaction) => void\\n  ): Promise<Transaction>;\\n\\n  getPendingTransactions(\\n    callback?: (error: Error, result: Transaction[]) => void\\n  ): Promise<Transaction[]>;\\n\\n  getTransactionFromBlock(\\n    hashStringOrNumber: string | number,\\n    indexNumber: number,\\n    callback?: (error: Error, transaction: Transaction) => void\\n  ): Promise<Transaction>;\\n\\n  getTransactionReceipt(\\n    hash: string,\\n    callback?: (\\n      error: Error,\\n      transactionReceipt: TransactionReceipt\\n    ) => void\\n  ): Promise<TransactionReceipt>;\\n\\n  getTransactionCount(address: string): Promise<number>;\\n  getTransactionCount(\\n    address: string,\\n    defaultBlock: number | string\\n  ): Promise<number>;\\n  getTransactionCount(\\n    address: string,\\n    callback?: (error: Error, count: number) => void\\n  ): Promise<number>;\\n  getTransactionCount(\\n    address: string,\\n    defaultBlock: number | string,\\n    callback?: (error: Error, count: number) => void\\n  ): Promise<number>;\\n\\n  sendTransaction(\\n    transactionConfig: TransactionConfig,\\n    callback?: (error: Error, hash: string) => void\\n  ): PromiEvent<TransactionReceipt>;\\n\\n  sendSignedTransaction(\\n    signedTransactionData: string,\\n    callback?: (error: Error, hash: string) => void\\n  ): PromiEvent<TransactionReceipt>;\\n\\n  sign(\\n    dataToSign: string,\\n    address: string | number,\\n    callback?: (error: Error, signature: string) => void\\n  ): Promise<string>;\\n\\n  signTransaction(\\n    transactionConfig: TransactionConfig,\\n    callback?: (\\n      error: Error,\\n      signedTransaction: RLPEncodedTransaction\\n    ) => void\\n  ): Promise<RLPEncodedTransaction>;\\n  signTransaction(\\n    transactionConfig: TransactionConfig,\\n    address: string\\n  ): Promise<RLPEncodedTransaction>;\\n  signTransaction(\\n    transactionConfig: TransactionConfig,\\n    address: string,\\n    callback: (\\n      error: Error,\\n      signedTransaction: RLPEncodedTransaction\\n    ) => void\\n  ): Promise<RLPEncodedTransaction>;\\n\\n  call(transactionConfig: TransactionConfig): Promise<string>;\\n  call(\\n    transactionConfig: TransactionConfig,\\n    defaultBlock?: number | string\\n  ): Promise<string>;\\n  call(\\n    transactionConfig: TransactionConfig,\\n    callback?: (error: Error, data: string) => void\\n  ): Promise<string>;\\n  call(\\n    transactionConfig: TransactionConfig,\\n    defaultBlock: number | string,\\n    callback: (error: Error, data: string) => void\\n  ): Promise<string>;\\n\\n  estimateGas(\\n    transactionConfig: TransactionConfig,\\n    callback?: (error: Error, gas: number) => void\\n  ): Promise<number>;\\n\\n  getPastLogs(\\n    options: PastLogsOptions,\\n    callback?: (error: Error, logs: Log[]) => void\\n  ): Promise<Log[]>;\\n\\n  getWork(\\n    callback?: (error: Error, result: string[]) => void\\n  ): Promise<string[]>;\\n\\n  submitWork(\\n    data: [string, string, string],\\n    callback?: (error: Error, result: boolean) => void\\n  ): Promise<boolean>;\\n\\n  getProof(\\n    address: string,\\n    storageKey: string[],\\n    blockNumber: number | string | 'latest' | 'earliest',\\n    callback?: (error: Error, result: GetProof) => void\\n  ): Promise<GetProof>;\\n}\\n\\ndeclare interface Syncing {\\n  StartingBlock: number;\\n  CurrentBlock: number;\\n  HighestBlock: number;\\n  KnownStates: number;\\n  PulledStates: number;\\n}\\n\\ndeclare interface BlockHeader {\\n  number: number;\\n  hash: string;\\n  parentHash: string;\\n  nonce: string;\\n  sha3Uncles: string;\\n  logsBloom: string;\\n  transactionRoot: string;\\n  stateRoot: string;\\n  receiptRoot: string;\\n  miner: string;\\n  extraData: string;\\n  gasLimit: number;\\n  gasUsed: number;\\n  timestamp: number | string;\\n}\\n\\ndeclare interface Block extends BlockHeader {\\n  transactions: Transaction[] | string[];\\n  size: number;\\n  difficulty: number;\\n  totalDifficulty: number;\\n  uncles: string[];\\n}\\n\\ndeclare interface PastLogsOptions {\\n  fromBlock?: number | string;\\n  toBlock?: number | string;\\n  address?: string | string[];\\n  topics?: Array<string | string[]>;\\n}\\n\\ndeclare interface LogsOptions {\\n  fromBlock?: number | string;\\n  address?: string | string[];\\n  topics?: Array<string | string[] | null>;\\n}\\n\\ndeclare interface GetProof {\\n  jsonrpc: string;\\n  id: number;\\n  result: {\\n    address: string;\\n    accountProof: string[];\\n    balance: string;\\n    codeHash: string;\\n    nonce: string;\\n    storageHash: string;\\n    storageProof: StorageProof[];\\n  };\\n}\\n\\ndeclare interface StorageProof {\\n  key: string;\\n  value: string;\\n  proof: string[];\\n}\\n\\ndeclare interface Bzz {\\n  constructor(provider: any);\\n\\n  readonly givenProvider: any;\\n  defaultAccount: string | null;\\n  defaultBlock: string | number;\\n  readonly currentProvider: any;\\n  setProvider(provider: any): boolean;\\n  BatchRequest: new () => any;\\n  providers: any;\\n\\n  upload(data: any): Promise<string>;\\n\\n  download(bzzHash: string, localPath?: string): Promise<any>;\\n\\n  pick: any;\\n}\\n\\ndeclare interface Web3 {\\n  constructor(provider: provider, net?: any);\\n\\n  modules: Modules;\\n  readonly givenProvider: any;\\n  defaultAccount: string | null;\\n  defaultBlock: string | number;\\n  readonly currentProvider: provider;\\n  setProvider(provider: provider): boolean;\\n  BatchRequest: new () => BatchRequest;\\n  readonly providers: Providers;\\n\\n  utils: Utils;\\n  eth: Eth;\\n  bzz: Bzz;\\n  version: string;\\n  extend(extension: Extension): any;\\n}\\n\\ndeclare interface Modules {\\n  Eth: new (provider: provider, net: any) => Eth;\\n  Net: new (provider: provider, net: any) => NetworkBase;\\n  Personal: new (provider: provider, net: any) => Personal;\\n  Shh: any;\\n  Bzz: new (provider: provider) => Bzz;\\n}\\n\\ndeclare interface ContractOptions {\\n  // Sender to use for contract calls\\n  from?: string\\n  // Gas price to use for contract calls\\n  gasPrice?: string\\n  // Gas to use for contract calls\\n  gas?: number\\n  // Contract code\\n  data?: string\\n}\\n\\ndeclare interface SendOptions {\\n  from: string;\\n  gasPrice?: string;\\n  gas?: number;\\n  value?: number | string | BN;\\n}\\n\\ndeclare interface EstimateGasOptions {\\n  from?: string;\\n  gas?: number;\\n  value?: number | string | BN;\\n}\\n\\ndeclare interface EventOptions {\\n  filter?: any;\\n  fromBlock?: number;\\n  toBlock?: string | number;\\n  topics?: any[];\\n}\\n\\ndeclare interface EventData {\\n  returnValues: {\\n    [key: string]: any;\\n  };\\n  raw: {\\n    data: string;\\n    topics: string[];\\n  };\\n  event: string;\\n  signature: string;\\n  logIndex: number;\\n  transactionIndex: number;\\n  transactionHash: string;\\n  blockHash: string;\\n  blockNumber: number;\\n  address: string;\\n}\\n\\n\\ndeclare interface Options extends ContractOptions {\\n  address: string;\\n  jsonInterface: AbiItem[];\\n}\\n\\ndeclare interface DeployOptions {\\n  data: string;\\n  arguments?: any[];\\n}\\n\\ndeclare interface ContractSendMethod {\\n  send(\\n    options: SendOptions,\\n    callback?: (err: Error, transactionHash: string) => void\\n  ): PromiEvent<Contract>;\\n\\n  estimateGas(\\n    options: EstimateGasOptions,\\n    callback?: (err: Error, gas: number) => void\\n  ): Promise<number>;\\n\\n  estimateGas(callback: (err: Error, gas: number) => void): Promise<number>;\\n\\n  estimateGas(\\n    options: EstimateGasOptions,\\n    callback: (err: Error, gas: number) => void\\n  ): Promise<number>;\\n\\n  estimateGas(options: EstimateGasOptions): Promise<number>;\\n\\n  estimateGas(): Promise<number>;\\n\\n  encodeABI(): string;\\n}\\n\\ndeclare interface Contract {\\n  defaultAccount: string | null\\n  defaultBlock: string | number\\n  defaultCommon: Common\\n  defaultHardfork: hardfork\\n  defaultChain: chain\\n  transactionPollingTimeout: number\\n  transactionConfirmationBlocks: number\\n  transactionBlockTimeout: number\\n  options: Options\\n  clone(): Contract\\n  deploy(options: DeployOptions): ContractSendMethod\\n  once(event: string, callback: (error: Error, event: EventData) => void): void\\n  once(\\n    event: string,\\n    options: EventOptions,\\n    callback: (error: Error, event: EventData) => void\\n  ): void\\n  events: any\\n  getPastEvents(event: string): Promise<EventData[]>\\n  getPastEvents(\\n    event: string,\\n    options: EventOptions,\\n    callback: (error: Error, event: EventData) => void\\n  ): Promise<EventData[]>\\n  getPastEvents(event: string, options: EventOptions): Promise<EventData[]>\\n  getPastEvents(\\n    event: string,\\n    callback: (error: Error, event: EventData) => void\\n  ): Promise<EventData[]>\\n\\n  contractMethods: any\\n}\\n\\ndeclare var web3: Web3\\n\"","export default \"\\n\\ndeclare type Bytes = ArrayLike<number>\\ndeclare type BytesLike = Bytes | string\\ndeclare type DataOptions = {\\n  allowMissingPrefix?: boolean\\n  hexPad?: 'left' | 'right' | null\\n}\\ndeclare interface Hexable {\\n  toHexString(): string\\n}\\ndeclare type SignatureLike =\\n  | {\\n    r: string\\n    s?: string\\n    _vs?: string\\n    recoveryParam?: number\\n    v?: number\\n  }\\n  | BytesLike\\ndeclare interface Signature {\\n  r: string\\n  s: string\\n  _vs: string\\n  recoveryParam: number\\n  v: number\\n}\\ndeclare function isBytesLike(value: any): value is BytesLike\\ndeclare function isBytes(value: any): value is Bytes\\ndeclare function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array\\ndeclare function concat(items: Array<BytesLike>): Uint8Array\\ndeclare function stripZeros(value: BytesLike): Uint8Array\\ndeclare function zeroPad(value: BytesLike, length: number): Uint8Array\\ndeclare function isHexString(value: any, length?: number): boolean\\ndeclare function hexlify(value: BytesLike | Hexable | number, options?: DataOptions): string\\ndeclare function hexDataLength(data: BytesLike): number\\ndeclare function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string\\ndeclare function hexConcat(items: Array<BytesLike>): string\\ndeclare function hexValue(value: BytesLike | Hexable | number): string\\ndeclare function hexStripZeros(value: BytesLike): string\\ndeclare function hexZeroPad(value: BytesLike, length: number): string\\ndeclare function splitSignature(signature: SignatureLike): Signature\\ndeclare function joinSignature(signature: SignatureLike): string\\n\\n/**\\n *  getNetwork\\n *\\n *  Converts a named common networks or chain ID (network ID) to a Network\\n *  and verifies a network is a valid Network..\\n */\\ndeclare function getNetwork(network: Networkish): Network\\n\\ndeclare function defineReadOnly<T, K extends keyof T>(object: T, name: K, value: T[K]): void\\ndeclare function getStatic<T>(ctor: any, key: string): T\\ndeclare type Deferrable<T> = {\\n  [K in keyof T]: T[K] | Promise<T[K]>\\n}\\ndeclare function resolveProperties<T>(object: Readonly<Deferrable<T>>): Promise<T>\\ndeclare function checkProperties(\\n  object: any,\\n  properties: {\\n    [name: string]: boolean\\n  }\\n): void\\ndeclare function shallowCopy<T>(object: T): T\\ndeclare function deepCopy<T>(object: T): T\\ndeclare class Description<T = any> {\\n  constructor(\\n    info: {\\n      [K in keyof T]: T[K]\\n    }\\n  )\\n}\\n\\ndeclare type UnsignedTransaction = {\\n  to?: string\\n  nonce?: number\\n  gasLimit?: BigNumberish\\n  gasPrice?: BigNumberish\\n  data?: BytesLike\\n  value?: BigNumberish\\n  chainId?: number\\n}\\ndeclare interface Transaction {\\n  hash?: string\\n  to?: string\\n  from?: string\\n  nonce: number\\n  gasLimit: BigNumber\\n  gasPrice: BigNumber\\n  data: string\\n  value: BigNumber\\n  chainId: number\\n  r?: string\\n  s?: string\\n  v?: number\\n}\\ndeclare function computeAddress(key: BytesLike | string): string\\ndeclare function recoverAddress(digest: BytesLike, signature: SignatureLike): string\\ndeclare function serialize(transaction: UnsignedTransaction, signature?: SignatureLike): string\\ndeclare function parse(rawTransaction: BytesLike): Transaction\\n\\ndeclare type ConnectionInfo = {\\n  url: string\\n  user?: string\\n  password?: string\\n  allowInsecureAuthentication?: boolean\\n  throttleLimit?: number\\n  timeout?: number\\n  headers?: {\\n    [key: string]: string | number\\n  }\\n}\\ndeclare interface OnceBlockable {\\n  once(eventName: 'block', handler: () => void): void\\n}\\ndeclare interface OncePollable {\\n  once(eventName: 'poll', handler: () => void): void\\n}\\ndeclare type PollOptions = {\\n  timeout?: number\\n  floor?: number\\n  ceiling?: number\\n  interval?: number\\n  retryLimit?: number\\n  onceBlock?: OnceBlockable\\n  oncePoll?: OncePollable\\n}\\ndeclare type FetchJsonResponse = {\\n  statusCode: number\\n  headers: {\\n    [header: string]: string\\n  }\\n}\\ndeclare function fetchJson(connection: string | ConnectionInfo, json?: string, processFunc?: (value: any, response: FetchJsonResponse) => any): Promise<any>\\ndeclare function poll<T>(func: () => Promise<T>, options?: PollOptions): Promise<T>\\n\\ndeclare type TransactionRequest = {\\n  to?: string\\n  from?: string\\n  nonce?: BigNumberish\\n  gasLimit?: BigNumberish\\n  gasPrice?: BigNumberish\\n  data?: BytesLike\\n  value?: BigNumberish\\n  chainId?: number\\n}\\ndeclare interface TransactionResponse extends Transaction {\\n  hash: string\\n  blockNumber?: number\\n  blockHash?: string\\n  timestamp?: number\\n  confirmations: number\\n  from: string\\n  raw?: string\\n  wait: (confirmations?: number) => Promise<TransactionReceipt>\\n}\\ndeclare type BlockTag = string | number\\ninterface _Block {\\n  hash: string\\n  parentHash: string\\n  number: number\\n  timestamp: number\\n  nonce: string\\n  difficulty: number\\n  gasLimit: BigNumber\\n  gasUsed: BigNumber\\n  miner: string\\n  extraData: string\\n}\\ndeclare interface Block extends _Block {\\n  transactions: Array<string>\\n}\\ndeclare interface BlockWithTransactions extends _Block {\\n  transactions: Array<TransactionResponse>\\n}\\ndeclare interface Log {\\n  blockNumber: number\\n  blockHash: string\\n  transactionIndex: number\\n  removed: boolean\\n  address: string\\n  data: string\\n  topics: Array<string>\\n  transactionHash: string\\n  logIndex: number\\n}\\ndeclare interface TransactionReceipt {\\n  to: string\\n  from: string\\n  contractAddress: string\\n  transactionIndex: number\\n  root?: string\\n  gasUsed: BigNumber\\n  logsBloom: string\\n  blockHash: string\\n  transactionHash: string\\n  logs: Array<Log>\\n  blockNumber: number\\n  confirmations: number\\n  cumulativeGasUsed: BigNumber\\n  byzantium: boolean\\n  status?: number\\n}\\ndeclare interface EventFilter {\\n  address?: string\\n  topics?: Array<string | Array<string>>\\n}\\ndeclare interface Filter extends EventFilter {\\n  fromBlock?: BlockTag\\n  toBlock?: BlockTag\\n}\\ndeclare interface FilterByBlockHash extends EventFilter {\\n  blockHash?: string\\n}\\ndeclare abstract class ForkEvent extends Description {\\n  readonly expiry: number\\n  readonly _isForkEvent?: boolean\\n  static isForkEvent(value: any): value is ForkEvent\\n}\\ndeclare class BlockForkEvent extends ForkEvent {\\n  readonly blockHash: string\\n  readonly _isBlockForkEvent?: boolean\\n  constructor(blockHash: string, expiry?: number)\\n}\\ndeclare class TransactionForkEvent extends ForkEvent {\\n  readonly hash: string\\n  readonly _isTransactionOrderForkEvent?: boolean\\n  constructor(hash: string, expiry?: number)\\n}\\ndeclare class TransactionOrderForkEvent extends ForkEvent {\\n  readonly beforeHash: string\\n  readonly afterHash: string\\n  constructor(beforeHash: string, afterHash: string, expiry?: number)\\n}\\ndeclare type EventType = string | Array<string | Array<string>> | EventFilter | ForkEvent\\ndeclare type Listener = (...args: Array<any>) => void\\ndeclare abstract class Provider implements OnceBlockable {\\n  abstract getNetwork(): Promise<Network>\\n  abstract getBlockNumber(): Promise<number>\\n  abstract getGasPrice(): Promise<BigNumber>\\n  abstract getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>\\n  abstract getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>\\n  abstract getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>\\n  abstract getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>\\n  abstract sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>\\n  abstract call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>\\n  abstract estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>\\n  abstract getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>\\n  abstract getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>\\n  abstract getTransaction(transactionHash: string): Promise<TransactionResponse>\\n  abstract getTransactionReceipt(transactionHash: string): Promise<TransactionReceipt>\\n  abstract getLogs(filter: Filter): Promise<Array<Log>>\\n  abstract resolveName(name: string | Promise<string>): Promise<string>\\n  abstract lookupAddress(address: string | Promise<string>): Promise<string>\\n  abstract on(eventName: EventType, listener: Listener): Provider\\n  abstract once(eventName: EventType, listener: Listener): Provider\\n  abstract emit(eventName: EventType, ...args: Array<any>): boolean\\n  abstract listenerCount(eventName?: EventType): number\\n  abstract listeners(eventName?: EventType): Array<Listener>\\n  abstract off(eventName: EventType, listener?: Listener): Provider\\n  abstract removeAllListeners(eventName?: EventType): Provider\\n  addListener(eventName: EventType, listener: Listener): Provider\\n  removeListener(eventName: EventType, listener: Listener): Provider\\n  abstract waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>\\n  readonly _isProvider: boolean\\n  constructor()\\n  static isProvider(value: any): value is Provider\\n}\\n\\ndeclare interface ExternallyOwnedAccount {\\n  readonly address: string\\n  readonly privateKey: string\\n}\\ndeclare abstract class Signer {\\n  readonly provider?: Provider\\n  abstract getAddress(): Promise<string>\\n  abstract signMessage(message: Bytes | string): Promise<string>\\n  abstract signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>\\n  abstract connect(provider: Provider): Signer\\n  readonly _isSigner: boolean\\n  constructor()\\n  getBalance(blockTag?: BlockTag): Promise<BigNumber>\\n  getTransactionCount(blockTag?: BlockTag): Promise<number>\\n  estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>\\n  call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag): Promise<string>\\n  sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>\\n  getChainId(): Promise<number>\\n  getGasPrice(): Promise<BigNumber>\\n  resolveName(name: string): Promise<string>\\n  checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest>\\n  populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest>\\n  _checkProvider(operation?: string): void\\n  static isSigner(value: any): value is Signer\\n}\\ndeclare class VoidSigner extends Signer {\\n  readonly address: string\\n  constructor(address: string, provider?: Provider)\\n  getAddress(): Promise<string>\\n  _fail(message: string, operation: string): Promise<any>\\n  signMessage(message: Bytes | string): Promise<string>\\n  signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>\\n  connect(provider: Provider): VoidSigner\\n}\\n\\ndeclare interface Overrides {\\n  gasLimit?: BigNumberish | Promise<BigNumberish>\\n  gasPrice?: BigNumberish | Promise<BigNumberish>\\n  nonce?: BigNumberish | Promise<BigNumberish>\\n}\\ndeclare interface PayableOverrides extends Overrides {\\n  value?: BigNumberish | Promise<BigNumberish>\\n}\\ndeclare interface CallOverrides extends PayableOverrides {\\n  blockTag?: BlockTag | Promise<BlockTag>\\n  from?: string | Promise<string>\\n}\\ndeclare interface PopulatedTransaction {\\n  to?: string\\n  from?: string\\n  nonce?: number\\n  gasLimit?: BigNumber\\n  gasPrice?: BigNumber\\n  data?: string\\n  value?: BigNumber\\n  chainId?: number\\n}\\ndeclare type EventFilter = {\\n  address?: string\\n  topics?: Array<string | Array<string>>\\n}\\ndeclare type ContractFunction<T = any> = (...args: Array<any>) => Promise<T>\\ndeclare interface Event extends Log {\\n  event?: string\\n  eventSignature?: string\\n  args?: Result\\n  decodeError?: Error\\n  decode?: (data: string, topics?: Array<string>) => any\\n  removeListener: () => void\\n  getBlock: () => Promise<Block>\\n  getTransaction: () => Promise<TransactionResponse>\\n  getTransactionReceipt: () => Promise<TransactionReceipt>\\n}\\ndeclare interface ContractReceipt extends TransactionReceipt {\\n  events?: Array<Event>\\n}\\ndeclare interface ContractTransaction extends TransactionResponse {\\n  wait(confirmations?: number): Promise<ContractReceipt>\\n}\\ndeclare class RunningEvent {\\n  readonly tag: string\\n  readonly filter: EventFilter\\n  private _listeners\\n  constructor(tag: string, filter: EventFilter)\\n  addListener(listener: Listener, once: boolean): void\\n  removeListener(listener: Listener): void\\n  removeAllListeners(): void\\n  listeners(): Array<Listener>\\n  listenerCount(): number\\n  run(args: Array<any>): number\\n  prepareEvent(event: Event): void\\n  getEmit(event: Event): Array<any>\\n}\\ndeclare type ContractInterface = string | Array<Fragment | JsonFragment | string> | Interface\\n\\ndeclare class Contract {\\n  readonly address: string\\n  readonly interface: Interface\\n  readonly signer: Signer\\n  readonly provider: Provider\\n  readonly functions: {\\n    [name: string]: ContractFunction\\n  }\\n  readonly callStatic: {\\n    [name: string]: ContractFunction\\n  }\\n  readonly estimateGas: {\\n    [name: string]: ContractFunction<BigNumber>\\n  }\\n  readonly populateTransaction: {\\n    [name: string]: ContractFunction<PopulatedTransaction>\\n  }\\n  readonly filters: {\\n    [name: string]: (...args: Array<any>) => EventFilter\\n  }\\n  readonly [key: string]: ContractFunction | any\\n  readonly resolvedAddress: Promise<string>\\n  readonly deployTransaction: TransactionResponse\\n  _deployedPromise: Promise<Contract>\\n  _runningEvents: {\\n    [eventTag: string]: RunningEvent\\n  }\\n  _wrappedEmits: {\\n    [eventTag: string]: (...args: Array<any>) => void\\n  }\\n  constructor(addressOrName: string, contractInterface: ContractInterface, signerOrProvider?: Signer | Provider)\\n  static getContractAddress(transaction: { from: string; nonce: BigNumberish }): string\\n  static getInterface(contractInterface: ContractInterface): Interface\\n  deployed(): Promise<Contract>\\n  _deployed(blockTag?: BlockTag): Promise<Contract>\\n  fallback(overrides?: TransactionRequest): Promise<TransactionResponse>\\n  connect(signerOrProvider: Signer | Provider | string): Contract\\n  attach(addressOrName: string): Contract\\n  static isIndexed(value: any): value is Indexed\\n  private _normalizeRunningEvent\\n  private _getRunningEvent\\n  _checkRunningEvents(runningEvent: RunningEvent): void\\n  _wrapEvent(runningEvent: RunningEvent, log: Log, listener: Listener): Event\\n  private _addEventListener\\n  queryFilter(event: EventFilter, fromBlockOrBlockhash?: BlockTag | string, toBlock?: BlockTag): Promise<Array<Event>>\\n  on(event: EventFilter | string, listener: Listener): this\\n  once(event: EventFilter | string, listener: Listener): this\\n  emit(eventName: EventFilter | string, ...args: Array<any>): boolean\\n  listenerCount(eventName?: EventFilter | string): number\\n  listeners(eventName?: EventFilter | string): Array<Listener>\\n  removeAllListeners(eventName?: EventFilter | string): this\\n  off(eventName: EventFilter | string, listener: Listener): this\\n  removeListener(eventName: EventFilter | string, listener: Listener): this\\n}\\ndeclare class ContractFactory {\\n  readonly interface: Interface\\n  readonly bytecode: string\\n  readonly signer: Signer\\n  constructor(\\n    contractInterface: ContractInterface,\\n    bytecode:\\n      | BytesLike\\n      | {\\n        object: string\\n      },\\n    signer?: Signer\\n  )\\n  getDeployTransaction(...args: Array<any>): TransactionRequest\\n  deploy(...args: Array<any>): Promise<Contract>\\n  attach(address: string): Contract\\n  connect(signer: Signer): ContractFactory\\n  static fromSolidity(compilerOutput: any, signer?: Signer): ContractFactory\\n  static getInterface(contractInterface: ContractInterface): Interface\\n  static getContractAddress(tx: { from: string; nonce: BytesLike | BigNumber | number }): string\\n  static getContract(address: string, contractInterface: ContractInterface, signer?: Signer): Contract\\n}\\n\\ndeclare const wordlists: {\\n  [locale: string]: Wordlist\\n}\\n\\ndeclare const defaultPath = \\\"m/44'/60'/0'/0/0\\\"\\ndeclare interface Mnemonic {\\n  readonly phrase: string\\n  readonly path: string\\n  readonly locale: string\\n}\\ndeclare class HDNode implements ExternallyOwnedAccount {\\n  readonly privateKey: string\\n  readonly publicKey: string\\n  readonly fingerprint: string\\n  readonly parentFingerprint: string\\n  readonly address: string\\n  readonly mnemonic?: Mnemonic\\n  readonly path: string\\n  readonly chainCode: string\\n  readonly index: number\\n  readonly depth: number\\n  /**\\n   *  This constructor should not be called directly.\\n   *\\n   *  Please use:\\n   *   - fromMnemonic\\n   *   - fromSeed\\n   */\\n  constructor(constructorGuard: any, privateKey: string, publicKey: string, parentFingerprint: string, chainCode: string, index: number, depth: number, mnemonicOrPath: Mnemonic | string)\\n  get extendedKey(): string\\n  neuter(): HDNode\\n  private _derive\\n  derivePath(path: string): HDNode\\n  static _fromSeed(seed: BytesLike, mnemonic: Mnemonic): HDNode\\n  static fromMnemonic(mnemonic: string, password?: string, wordlist?: string | Wordlist): HDNode\\n  static fromSeed(seed: BytesLike): HDNode\\n  static fromExtendedKey(extendedKey: string): HDNode\\n}\\ndeclare function mnemonicToSeed(mnemonic: string, password?: string): string\\ndeclare function mnemonicToEntropy(mnemonic: string, wordlist?: string | Wordlist): string\\ndeclare function entropyToMnemonic(entropy: BytesLike, wordlist?: string | Wordlist): string\\ndeclare function isValidMnemonic(mnemonic: string, wordlist?: Wordlist): boolean\\n\\ndeclare class SigningKey {\\n  readonly curve: string\\n  readonly privateKey: string\\n  readonly publicKey: string\\n  readonly compressedPublicKey: string\\n  readonly _isSigningKey: boolean\\n  constructor(privateKey: BytesLike)\\n  _addPoint(other: BytesLike): string\\n  signDigest(digest: BytesLike): Signature\\n  computeSharedSecret(otherKey: BytesLike): string\\n  static isSigningKey(value: any): value is SigningKey\\n}\\ndeclare function recoverPublicKey(digest: BytesLike, signature: SignatureLike): string\\ndeclare function computePublicKey(key: BytesLike, compressed?: boolean): string\\n\\ndeclare function decryptJsonWallet(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<ExternallyOwnedAccount>\\ndeclare function decryptJsonWalletSync(json: string, password: Bytes | string): ExternallyOwnedAccount\\n\\ndeclare class Wallet extends Signer implements ExternallyOwnedAccount {\\n  readonly address: string\\n  readonly provider: Provider\\n  readonly _signingKey: () => SigningKey\\n  readonly _mnemonic: () => Mnemonic\\n  constructor(privateKey: BytesLike | ExternallyOwnedAccount | SigningKey, provider?: Provider)\\n  get mnemonic(): Mnemonic\\n  get privateKey(): string\\n  get publicKey(): string\\n  getAddress(): Promise<string>\\n  connect(provider: Provider): Wallet\\n  signTransaction(transaction: TransactionRequest): Promise<string>\\n  signMessage(message: Bytes | string): Promise<string>\\n  encrypt(password: Bytes | string, options?: any, progressCallback?: ProgressCallback): Promise<string>\\n  /**\\n   *  Static methods to create Wallet instances.\\n   */\\n  static createRandom(options?: any): Wallet\\n  static fromEncryptedJson(json: string, password: Bytes | string, progressCallback?: ProgressCallback): Promise<Wallet>\\n  static fromEncryptedJsonSync(json: string, password: Bytes | string): Wallet\\n  static fromMnemonic(mnemonic: string, path?: string, wordlist?: Wordlist): Wallet\\n}\\ndeclare function verifyMessage(message: Bytes | string, signature: SignatureLike): string\\n\\ndeclare const AddressZero = '0x0000000000000000000000000000000000000000'\\ndeclare const HashZero = '0x0000000000000000000000000000000000000000000000000000000000000000'\\ndeclare const EtherSymbol = '\\\\u039E'\\ndeclare const NegativeOne: BigNumber\\ndeclare const Zero: BigNumber\\ndeclare const One: BigNumber\\ndeclare const Two: BigNumber\\ndeclare const WeiPerEther: BigNumber\\ndeclare const MaxUint256: BigNumber\\n\\ndeclare function getDefaultProvider(network?: Network | string, options?: any): BaseProvider\\n\\ndeclare enum LogLevel {\\n  DEBUG = 'DEBUG',\\n  INFO = 'INFO',\\n  WARNING = 'WARNING',\\n  ERROR = 'ERROR',\\n  OFF = 'OFF'\\n}\\ndeclare enum ErrorCode {\\n  UNKNOWN_ERROR = 'UNKNOWN_ERROR',\\n  NOT_IMPLEMENTED = 'NOT_IMPLEMENTED',\\n  UNSUPPORTED_OPERATION = 'UNSUPPORTED_OPERATION',\\n  NETWORK_ERROR = 'NETWORK_ERROR',\\n  SERVER_ERROR = 'SERVER_ERROR',\\n  TIMEOUT = 'TIMEOUT',\\n  BUFFER_OVERRUN = 'BUFFER_OVERRUN',\\n  NUMERIC_FAULT = 'NUMERIC_FAULT',\\n  MISSING_NEW = 'MISSING_NEW',\\n  INVALID_ARGUMENT = 'INVALID_ARGUMENT',\\n  MISSING_ARGUMENT = 'MISSING_ARGUMENT',\\n  UNEXPECTED_ARGUMENT = 'UNEXPECTED_ARGUMENT',\\n  CALL_EXCEPTION = 'CALL_EXCEPTION',\\n  INSUFFICIENT_FUNDS = 'INSUFFICIENT_FUNDS',\\n  NONCE_EXPIRED = 'NONCE_EXPIRED',\\n  REPLACEMENT_UNDERPRICED = 'REPLACEMENT_UNDERPRICED',\\n  UNPREDICTABLE_GAS_LIMIT = 'UNPREDICTABLE_GAS_LIMIT'\\n}\\ndeclare class Logger {\\n  readonly version: string\\n  static errors: typeof ErrorCode\\n  static levels: typeof LogLevel\\n  constructor(version: string)\\n  _log(logLevel: LogLevel, args: Array<any>): void\\n  debug(...args: Array<any>): void\\n  info(...args: Array<any>): void\\n  warn(...args: Array<any>): void\\n  makeError(message: string, code?: ErrorCode, params?: any): Error\\n  throwError(message: string, code?: ErrorCode, params?: any): never\\n  throwArgumentError(message: string, name: string, value: any): never\\n  checkNormalize(message?: string): void\\n  checkSafeUint53(value: number, message?: string): void\\n  checkArgumentCount(count: number, expectedCount: number, message?: string): void\\n  checkNew(target: any, kind: any): void\\n  checkAbstract(target: any, kind: any): void\\n  static globalLogger(): Logger\\n  static setCensorship(censorship: boolean, permanent?: boolean): void\\n  static setLogLevel(logLevel: LogLevel): void\\n}\\n\\ndeclare class AbiCoder {\\n  readonly coerceFunc: CoerceFunc\\n  constructor(coerceFunc?: CoerceFunc)\\n  _getCoder(param: ParamType): Coder\\n  _getWordSize(): number\\n  _getReader(data: Uint8Array): Reader\\n  _getWriter(): Writer\\n  encode(types: Array<string | ParamType>, values: Array<any>): string\\n  decode(types: Array<string | ParamType>, data: BytesLike): Result\\n}\\n\\ndeclare class utils {\\n  AbiCoder: typeof AbiCoder\\n  EventFragment()\\n  FormatTypes: { sighash: \\\"sighash\\\", minimal: \\\"minimal\\\", full: \\\"full\\\", json: \\\"json\\\" }\\n  Fragment(constructorGuard, params)\\n  FunctionFragment()\\n  HDNode(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath)\\n  Indexed()\\n  Interface(fragments$1)\\n  LogDescription()\\n  Logger(version)\\n  ParamType(constructorGuard, params)\\n  RLP: { __esModule: true, encode: any, decode: any }\\n  SigningKey(privateKey)\\n  SupportedAlgorithm: { sha256: \\\"sha256\\\", sha512: \\\"sha512\\\" }\\n  TransactionDescription()\\n  UnicodeNormalizationForm: { current: \\\"\\\", NFC: \\\"NFC\\\", NFD: \\\"NFD\\\", NFKC: \\\"NFKC\\\", NFKD: \\\"NFKD\\\" }\\n  Utf8ErrorFuncs: { error: any, ignore: any, replace: any }\\n  Utf8ErrorReason: { UNEXPECTED_CONTINUE: \\\"unexpected continuation byte\\\", BAD_PREFIX: \\\"bad codepoint prefix\\\", OVERRUN: \\\"string overrun\\\", MISSING_CONTINUE: \\\"missing continuation byte\\\", OUT_OF_RANGE: \\\"out of UTF-8 range\\\" }\\n  arrayify(value, options)\\n  base64: { __esModule: true, decode: any, encode: any }\\n  checkProperties(object, properties)\\n  checkResultErrors(result)\\n  commify(value)\\n  computeAddress(key)\\n  computeHmac(algorithm, key, data)\\n  computePublicKey(key, compressed)\\n  concat(items)\\n  deepCopy(object)\\n  defaultAbiCoder: AbiCoder\\n  defaultPath: \\\"m/44'/60'/0'/0/0\\\"\\n  defineReadOnly(object, name, value)\\n  entropyToMnemonic(entropy, wordlist)\\n  fetchJson(connection, json, processFunc)\\n  formatBytes32String(text)\\n  formatEther(wei)\\n  formatUnits(value, unitName)\\n  getAddress(address)\\n  getContractAddress(transaction)\\n  getCreate2Address(from, salt, initCodeHash)\\n  getIcapAddress(address)\\n  getJsonWalletAddress(json)\\n  getStatic(ctor, key)\\n  hashMessage(message)\\n  hexDataLength(data)\\n  hexDataSlice(data, offset, endOffset)\\n  hexStripZeros(value)\\n  hexValue(value)\\n  hexZeroPad(value, length)\\n  hexlify(value, options)\\n  id(text)\\n  isAddress(address)\\n  isBytes(value)\\n  isBytesLike(value)\\n  isHexString(value, length)\\n  isValidMnemonic(mnemonic, wordlist)\\n  isValidName(name)\\n  joinSignature(signature)\\n  keccak256(data)\\n  mnemonicToEntropy(mnemonic, wordlist)\\n  mnemonicToSeed(mnemonic, password)\\n  namehash(name)\\n  nameprep(value)\\n  parseBytes32String(bytes)\\n  parseEther(ether)\\n  parse(rawTransaction)\\n  parseUnits(value, unitName)\\n  poll(func, options)\\n  randomBytes(length)\\n  recoverAddress(digest, signature)\\n  recoverPublicKey(digest, signature)\\n  resolveProperties(object)\\n  ripemd160(data)\\n  serialize(transaction, signature)\\n  sha256(data)\\n  sha512(data)\\n  shallowCopy(object)\\n  shuffled(array)\\n  keccak256(types, values)\\n  pack(types, values)\\n  sha256(types, values)\\n  splitSignature(signature)\\n  stripZeros(value)\\n  toUtf8Bytes(str, form)\\n  toUtf8CodePoints(str, form)\\n  toUtf8String(bytes, onError)\\n  verifyMessage(message, signature)\\n  zeroPad(value, length)\\n  _toEscapedUtf8String(bytes, onError)\\n}\\n\\ndeclare class JsonRpcSigner extends Signer {\\n  readonly provider: JsonRpcProvider\\n  _index: number\\n  _address: string\\n  constructor(constructorGuard: any, provider: JsonRpcProvider, addressOrIndex?: string | number)\\n  connect(provider: Provider): JsonRpcSigner\\n  connectUnchecked(): JsonRpcSigner\\n  getAddress(): Promise<string>\\n  sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>\\n  signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>\\n  sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>\\n  signMessage(message: Bytes | string): Promise<string>\\n  _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>\\n  unlock(password: string): Promise<boolean>\\n}\\n\\ndeclare class UncheckedJsonRpcSigner extends JsonRpcSigner {\\n  sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>\\n}\\n\\ndeclare abstract class JsonRpcProvider {\\n  readonly connection: ConnectionInfo\\n  _pendingFilter: Promise<number>\\n  _nextId: number\\n  constructor(url?: ConnectionInfo | string, network?: Networkish)\\n  static defaultUrl(): string\\n  detectNetwork(): Promise<Network>\\n  getSigner(addressOrIndex?: string | number): JsonRpcSigner\\n  getUncheckedSigner(addressOrIndex?: string | number): UncheckedJsonRpcSigner\\n  listAccounts(): Promise<Array<string>>\\n  send(method: string, params: Array<any>): Promise<any>\\n  prepareRequest(method: string, params: any): [string, Array<any>]\\n  perform(method: string, params: any): Promise<any>\\n  _startEvent(event: Event): void\\n  _startPending(): void\\n  _stopEvent(event: Event): void\\n  static hexlifyTransaction(transaction: TransactionRequest, allowExtra?: {\\n    [key: string]: boolean\\n  }): {\\n    [key: string]: string\\n  }\\n}\\n\\ndeclare abstract class UrlJsonRpcProvider {\\n  readonly apiKey: any\\n  constructor(network?: Networkish, apiKey?: any)\\n  _startPending(): void\\n  isCommunityResource(): boolean\\n  getSigner(address?: string): JsonRpcSigner\\n  listAccounts(): Promise<Array<string>>\\n  static getApiKey(apiKey: any): any\\n  static getUrl(network: Network, apiKey: any): string | ConnectionInfo\\n}\\n\\ndeclare class AlchemyProvider extends UrlJsonRpcProvider {\\n  static getWebSocketProvider(network, apiKey): Provider\\n  static getApiKey(apiKey): string\\n  static getUrl(network, apiKey): string\\n}\\n\\ndeclare class InfuraProvider extends UrlJsonRpcProvider {\\n  static getWebSocketProvider(network, apiKey): Provider\\n  static getApiKey(apiKey): string\\n  static getUrl(network, apiKey): string\\n}\\n\\ndeclare class IpcProvider extends JsonRpcProvider {\\n  readonly path: string\\n  constructor(path: string, network?: Networkish)\\n  send(method: string, params: Array<any>): Promise<any>\\n}\\n\\ndeclare class NodesmithProvider extends UrlJsonRpcProvider {\\n  static getApiKey(apiKey: any): any\\n  static getUrl(network: Network, apiKey?: any): string\\n}\\n\\ndeclare class Web3Provider extends JsonRpcProvider {\\n  readonly provider: ExternalProvider\\n  readonly jsonRpcFetchFunc: JsonRpcFetchFunc\\n  constructor(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish)\\n  new(provider: ExternalProvider | JsonRpcFetchFunc, network?: Networkish)\\n  send(method: string, params: Array<any>): Promise<any>\\n}\\n\\ndeclare class WebSocketProvider extends JsonRpcProvider {\\n  readonly _websocket: any\\n  constructor(url: string, network?: Networkish)\\n  get pollingInterval(): number\\n  resetEventsBlock(blockNumber: number): void\\n  set pollingInterval(value: number)\\n  poll(): Promise<void>\\n  set polling(value: boolean)\\n  send(method: string, params?: Array<any>): Promise<any>\\n  static defaultUrl(): string\\n  _subscribe(tag: string, param: Array<any>, processFunc: (result: any) => void): Promise<void>\\n  _startEvent(event: Event): void\\n  _stopEvent(event: Event): void\\n}\\n\\ndeclare class CloudflareProvider extends UrlJsonRpcProvider {\\n  static getApiKey(apiKey: any): any\\n  static getUrl(network: Network, apiKey?: any): string\\n  perform(method: string, params: any): Promise<any>\\n}\\n\\ndeclare class Ethers {\\n  BigNumber: BigNumber\\n  Contract: Contract\\n  ContractFactory: Contract\\n  FixedNumber: FixedNumber\\n  Signer: Signer\\n  VoidSigner: VoidSigner\\n  Wallet: Wallet\\n  Wordlist: Wordlist\\n  constants: {\\n    AddressZero: \\\"0x0000000000000000000000000000000000000000\\\"\\n    EtherSymbol: \\\"Ξ\\\"\\n    HashZero: \\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\"\\n    MaxUint256: BigNumber\\n    NegativeOne: BigNumber\\n    One: BigNumber\\n    Two: BigNumber\\n    WeiPerEther: BigNumber\\n    Zero: BigNumber\\n  }\\n  errors: {\\n    BUFFER_OVERRUN: \\\"BUFFER_OVERRUN\\\"\\n    CALL_EXCEPTION: \\\"CALL_EXCEPTION\\\"\\n    INSUFFICIENT_FUNDS: \\\"INSUFFICIENT_FUNDS\\\"\\n    INVALID_ARGUMENT: \\\"INVALID_ARGUMENT\\\"\\n    MISSING_ARGUMENT: \\\"MISSING_ARGUMENT\\\"\\n    MISSING_NEW: \\\"MISSING_NEW\\\"\\n    NETWORK_ERROR: \\\"NETWORK_ERROR\\\"\\n    NONCE_EXPIRED: \\\"NONCE_EXPIRED\\\"\\n    NOT_IMPLEMENTED: \\\"NOT_IMPLEMENTED\\\"\\n    NUMERIC_FAULT: \\\"NUMERIC_FAULT\\\"\\n    REPLACEMENT_UNDERPRICED: \\\"REPLACEMENT_UNDERPRICED\\\"\\n    SERVER_ERROR: \\\"SERVER_ERROR\\\"\\n    TIMEOUT: \\\"TIMEOUT\\\"\\n    UNEXPECTED_ARGUMENT: \\\"UNEXPECTED_ARGUMENT\\\"\\n    UNKNOWN_ERROR: \\\"UNKNOWN_ERROR\\\"\\n    UNPREDICTABLE_GAS_LIMIT: \\\"UNPREDICTABLE_GAS_LIMIT\\\"\\n    UNSUPPORTED_OPERATION: \\\"UNSUPPORTED_OPERATION\\\"\\n  }\\n  getDefaultProvider(network, options): Provider\\n  logger: { version: \\\"ethers/5.0.4\\\" }\\n  providers: {\\n    AlchemyProvider: typeof AlchemyProvider\\n    BaseProvider: typeof BaseProvider\\n    CloudflareProvider: typeof CloudflareProvider\\n    EtherscanProvider: typeof EtherscanProvider\\n    FallbackProvider: typeof FallbackProvider\\n    Formatter: typeof Formatter\\n    InfuraProvider: typeof InfuraProvider\\n    IpcProvider: typeof null\\n    JsonRpcProvider: typeof JsonRpcProvider\\n    JsonRpcSigner: typeof JsonRpcSigner\\n    NodesmithProvider: typeof NodesmithProvider\\n    Provider: typeof Provider\\n    StaticJsonRpcProvider: typeof StaticJsonRpcProvider\\n    UrlJsonRpcProvider: typeof UrlJsonRpcProvider\\n    Web3Provider: typeof Web3Provider\\n    WebSocketProvider: typeof WebSocketProvider\\n    getDefaultProvider: typeof getDefaultProvider\\n    getNetwork: typeof getNetwork\\n  }\\n  utils: utils\\n  version: \\\"ethers/5.0.4\\\"\\n}\\n\\ndeclare const logger: utils.Logger\\n\\ndeclare const provider: Provider\\n\\ndeclare const ethers: Ethers\\n\"","export default \"declare type Bytes = ArrayLike<number>\\ndeclare type BytesLike = Bytes | string\\ndeclare type DataOptions = {\\n  allowMissingPrefix?: boolean\\n  hexPad?: 'left' | 'right' | null\\n}\\ndeclare interface Hexable {\\n  toHexString(): string\\n}\\ndeclare type SignatureLike =\\n  | {\\n    r: string\\n    s?: string\\n    _vs?: string\\n    recoveryParam?: number\\n    v?: number\\n  }\\n  | BytesLike\\ndeclare interface Signature {\\n  r: string\\n  s: string\\n  _vs: string\\n  recoveryParam: number\\n  v: number\\n}\\ndeclare function isBytesLike(value: any): value is BytesLike\\ndeclare function isBytes(value: any): value is Bytes\\ndeclare function arrayify(value: BytesLike | Hexable | number, options?: DataOptions): Uint8Array\\ndeclare function concat(items: Array<BytesLike>): Uint8Array\\ndeclare function stripZeros(value: BytesLike): Uint8Array\\ndeclare function zeroPad(value: BytesLike, length: number): Uint8Array\\ndeclare function isHexString(value: any, length?: number): boolean\\ndeclare function hexlify(value: BytesLike | Hexable | number, options?: DataOptions): string\\ndeclare function hexDataLength(data: BytesLike): number\\ndeclare function hexDataSlice(data: BytesLike, offset: number, endOffset?: number): string\\ndeclare function hexConcat(items: Array<BytesLike>): string\\ndeclare function hexValue(value: BytesLike | Hexable | number): string\\ndeclare function hexStripZeros(value: BytesLike): string\\ndeclare function hexZeroPad(value: BytesLike, length: number): string\\ndeclare function splitSignature(signature: SignatureLike): Signature\\ndeclare function joinSignature(signature: SignatureLike): string\\n\\ndeclare type BigNumberish = BigNumber | Bytes | string | number\\ndeclare function isBigNumberish(value: any): value is BigNumberish\\ndeclare class BigNumber implements Hexable {\\n  readonly _hex: string\\n  readonly _isBigNumber: boolean\\n  constructor(constructorGuard: any, hex: string)\\n  fromTwos(value: number): BigNumber\\n  toTwos(value: number): BigNumber\\n  abs(): BigNumber\\n  add(other: BigNumberish): BigNumber\\n  sub(other: BigNumberish): BigNumber\\n  div(other: BigNumberish): BigNumber\\n  mul(other: BigNumberish): BigNumber\\n  mod(other: BigNumberish): BigNumber\\n  pow(other: BigNumberish): BigNumber\\n  and(other: BigNumberish): BigNumber\\n  or(other: BigNumberish): BigNumber\\n  xor(other: BigNumberish): BigNumber\\n  mask(value: number): BigNumber\\n  shl(value: number): BigNumber\\n  shr(value: number): BigNumber\\n  eq(other: BigNumberish): boolean\\n  lt(other: BigNumberish): boolean\\n  lte(other: BigNumberish): boolean\\n  gt(other: BigNumberish): boolean\\n  gte(other: BigNumberish): boolean\\n  isNegative(): boolean\\n  isZero(): boolean\\n  toNumber(): number\\n  toString(): string\\n  toHexString(): string\\n  static from(value: any): BigNumber\\n  static isBigNumber(value: any): value is BigNumber\\n}\\n\\ndeclare class FixedNumber {\\n  readonly format: FixedFormat\\n  readonly _hex: string\\n  readonly _value: string\\n  readonly _isFixedNumber: boolean\\n  constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat)\\n  _checkFormat(other: FixedNumber): void\\n  addUnsafe(other: FixedNumber): FixedNumber\\n  subUnsafe(other: FixedNumber): FixedNumber\\n  mulUnsafe(other: FixedNumber): FixedNumber\\n  divUnsafe(other: FixedNumber): FixedNumber\\n  floor(): FixedNumber\\n  ceiling(): FixedNumber\\n  round(decimals?: number): FixedNumber\\n  isZero(): boolean\\n  isNegative(): boolean\\n  toString(): string\\n  toHexString(width?: number): string\\n  toUnsafeFloat(): number\\n  toFormat(format: FixedFormat | string): FixedNumber\\n  static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string): FixedNumber\\n  static fromString(value: string, format?: FixedFormat | string): FixedNumber\\n  static fromBytes(value: BytesLike, format?: FixedFormat | string): FixedNumber\\n  static from(value: any, format?: FixedFormat | string): FixedNumber\\n  static isFixedNumber(value: any): value is FixedNumber\\n}\\n\"","export default \"/**\\n * ************ This is an experimental dev feature ************\\n *\\n * Ready to use variables:\\n * - web3\\n * - {varName} with the contract chosed\\n *\\n * For More info check:\\n * https://web3js.readthedocs.io/en/v1.2.2/web3-eth-contract.html#web3-eth-contract\\n *\\n * Web3 doc:\\n * https://web3js.readthedocs.io/en/v1.2.2/\\n *\\n * The value returned should be convertible to a JSON string.\\n *\\n * Feedback is welcome :)\\n */\\n\\nasync function main() {\\n  /*\\n    const name = await contract.methods.name().call()\\n    return name\\n  */\\n}\\n\"","export default \"/**\\n * ************ This is an experimental dev feature ************\\n *\\n * Ready to use variables:\\n * - All ethers modules: Contract, Signer, Provider, Wallet, etc...\\n * - 'provider' with window provider\\n * - {varName} with the contract chosed\\n *\\n * For More info check:\\n * https://docs.ethers.io/v5/api/contract/contract/\\n *\\n * Ethers doc:\\n * https://docs.ethers.io/v5/api/\\n *\\n * The value returned should be convertible to a JSON string.\\n *\\n * Feedback is welcome :)\\n */\\n\\nasync function main() {\\n  /*\\n    const name = await contract.name()\\n    return name\\n  */\\n}\\n\"","/* eslint import/no-webpack-loader-syntax: off */\n// @ts-ignore\nimport web3Types from '!!raw-loader!./web3EditorTypes.d.ts'\n/* eslint import/no-webpack-loader-syntax: off */\n// @ts-ignore\nimport ethersTypes from '!!raw-loader!./ethersTypes.d.ts'\n// @ts-ignore\nimport ethersBigNumberTypes from '!!raw-loader!./ethersBignumberTypes.d.ts'\n/* eslint import/no-webpack-loader-syntax: off */\n/* eslint import/no-webpack-loader-syntax: off */\n// @ts-ignore\nimport web3DefaultScript from '!!raw-loader!./web3DefaultScript.js'\n/* eslint import/no-webpack-loader-syntax: off */\n// @ts-ignore\nimport ethersDefaultScript from '!!raw-loader!./ethersDefaultScript.js'\n\nimport { LIB } from '../../../constants'\n\nexport function getEditorTypes(library: LIB): string {\n  switch (library) {\n    case LIB.WEB3:\n      return web3Types\n    case LIB.ETHERS:\n      return ethersBigNumberTypes.concat(ethersTypes)\n    default:\n      return ''\n  }\n}\n\nexport function getDefaultScript(library: LIB): string {\n  switch (library) {\n    case LIB.WEB3:\n      return web3DefaultScript\n    case LIB.ETHERS:\n      return ethersDefaultScript\n    default:\n      return ''\n  }\n}\n","import React, { useState, useEffect, useRef, useCallback } from 'react'\nimport MonacoEditor from 'react-monaco-editor'\nimport * as monacoEditor from 'monaco-editor/esm/vs/editor/editor.api'\n\nimport { SelectedContracts } from 'components/Playground/types'\nimport { UploadModal } from 'components/Modals'\nimport { typeContractMethods } from 'libs/contract'\nimport { isIOS } from 'libs/device'\nimport { saveLastUsedCode, getLastUsedCode } from 'libs/localstorage'\nimport { setBeforeUnload } from 'libs/beforeUnload'\nimport { getEditorTypes, getDefaultScript } from './editorTypes'\nimport { Props } from './types'\n\nimport './Editor.css'\nimport { injectGlobals } from 'libs/global'\n\nexport const OUTPUT_HEADLINE = '/***** Output *****/\\n'\n\nlet currentCode: string\n\nexport default function Editor(props: Props) {\n  const {\n    contracts,\n    library,\n    initCode,\n    isMaximized,\n    onChangeSize,\n    isLoading\n  } = props\n\n  const defaultScript = getDefaultScript(library)\n  const editorTypes = getEditorTypes(library)\n\n  const [code, setCode] = useState(defaultScript)\n  const [copyText, setCopyText] = useState('Copy')\n  const [isRunning, setIsRunning] = useState(false)\n  const [output, setOutput] = useState<string | null>(null)\n  const [error, setError] = useState<string | null>(null)\n  const [isModalOpen, setIsModalOpen] = useState(false)\n  const prevContracts = usePrevious(contracts)\n\n  let monacoRef = useRef<typeof monacoEditor | null>(null)\n  let textareaRef: HTMLTextAreaElement\n\n  // Hack to make Monaco editor addCommand works\n  currentCode = code\n\n  const instanceWindowVars = useCallback(\n    async () => injectGlobals(library, prevContracts, contracts),\n    [library, contracts, prevContracts]\n  )\n\n  function usePrevious(value: SelectedContracts) {\n    const ref = useRef<SelectedContracts>()\n    useEffect(() => {\n      ref.current = value\n    })\n    return ref.current\n  }\n\n  // Did Mount\n  useEffect(() => {\n    let code\n    if (initCode) {\n      code = initCode\n    } else {\n      code = getLastUsedCode()\n    }\n\n    if (code) {\n      setCode(code)\n    }\n  }, [initCode])\n\n  useEffect(() => {\n    if (monacoRef.current && !isLoading) {\n      monacoRef.current.languages.typescript.typescriptDefaults.addExtraLib(\n        typeContractMethods(editorTypes, contracts, library),\n        'index.d.ts'\n      )\n      instanceWindowVars()\n    }\n  }, [editorTypes, contracts, instanceWindowVars, library, isLoading])\n\n  function editorWillMount(monaco: typeof monacoEditor) {\n    monaco.languages.typescript.typescriptDefaults.addExtraLib(\n      typeContractMethods(editorTypes, contracts, library),\n      'index.d.ts'\n    )\n\n    monacoRef.current = monaco\n    instanceWindowVars()\n  }\n\n  function editorDidMount(\n    editor: monacoEditor.editor.IStandaloneCodeEditor,\n    monaco: typeof monacoEditor\n  ) {\n    const model = editor.getModel()\n    if (model && model.getModeId() === 'typescript') {\n      editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S, () => {\n        saveLastUsedCode(currentCode)\n        editor.trigger('format', 'editor.action.formatDocument', null)\n      })\n      editor.addCommand(\n        monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter,\n        handleExecuteCode\n      )\n      editor.addCommand(\n        monaco.KeyMod.CtrlCmd | monaco.KeyMod.Shift | monaco.KeyCode.KEY_E,\n        handleExecuteCode\n      )\n    }\n  }\n\n  function cleanState() {\n    setIsRunning(true)\n    setOutput(null)\n    setError(null)\n  }\n\n  async function handleExecuteCode() {\n    saveLastUsedCode(currentCode)\n\n    let output: string\n\n    const setOutputState = (...values: any) => {\n      if (output === undefined) {\n        output = ''\n      }\n\n      if (values.length > 1) {\n        values.forEach(\n          (value: any) => (output += JSON.stringify(value, null, 2) + '\\n')\n        )\n      } else {\n        output += JSON.stringify(values[0], null, 2) + '\\n'\n      }\n\n      setOutput(output)\n    }\n\n    try {\n      cleanState()\n      setOutputState(\n        // eslint-disable-next-line\n        await eval(`\n       (function(){\n          const console = {}\n\n          console.log = function() {\n            setOutputState(...arguments)\n          }\n          ${currentCode}\n          return main()\n        })()\n      `)\n      )\n    } catch (e) {\n      setError(e.stack)\n    }\n    setIsRunning(false)\n  }\n\n  function handleCodeChange(newValue: string) {\n    setBeforeUnload()\n    setCode(newValue)\n  }\n\n  function handleResetCode() {\n    handleCodeChange(defaultScript)\n  }\n\n  function handleCopy() {\n    setCopyText('Copied')\n\n    if (isIOS()) {\n      const range = document.createRange()\n      range.selectNodeContents(textareaRef)\n      const selection = window.getSelection()\n      if (selection) {\n        selection.removeAllRanges()\n        selection.addRange(range)\n      }\n      textareaRef.setSelectionRange(0, 999999)\n    } else {\n      textareaRef.select()\n    }\n\n    document.execCommand('copy')\n\n    window.setTimeout(() => setCopyText('Copy'), 1000)\n  }\n\n  function handleClearOutput() {\n    setOutput(null)\n    setError(null)\n  }\n\n  function toggleModal() {\n    saveLastUsedCode(currentCode)\n    setIsModalOpen(!isModalOpen)\n  }\n\n  let outputValue = OUTPUT_HEADLINE\n\n  if (isRunning) {\n    outputValue = 'Running...'\n  } else if (output) {\n    outputValue = output\n  }\n\n  if (error) {\n    outputValue += error\n  }\n\n  return (\n    <>\n      <div className={`Editor ${isMaximized ? ' maximized' : ''}`}>\n        <div className=\"code-wrapper\">\n          <div className=\"actions\">\n            <div className=\"col left\">\n              <button onClick={onChangeSize} title=\"Hide\">\n                {isMaximized ? (\n                  <i className=\"icon hide\" />\n                ) : (\n                  <i className=\"icon maximize\" />\n                )}\n                {isMaximized ? 'Minimize' : 'Maximize'}\n              </button>\n              <button onClick={handleExecuteCode} title=\"Run\">\n                <i className=\"icon run\" />\n                {'Run'}\n              </button>\n              <button onClick={toggleModal} title=\"Upload & Share\">\n                <i className=\"icon upload\" />\n                {'Save & Share'}\n              </button>\n            </div>\n            <div className=\"col right\">\n              <button onClick={handleResetCode} title=\"Reset\">\n                <i className=\"icon reset\" />\n                {'Reset'}\n              </button>\n            </div>\n          </div>\n          <MonacoEditor\n            language=\"typescript\"\n            theme=\"vs-dark\"\n            value={currentCode}\n            onChange={handleCodeChange}\n            editorWillMount={editorWillMount}\n            editorDidMount={editorDidMount}\n            options={{\n              automaticLayout: true,\n              lineNumbers: 'off',\n              minimap: { enabled: false },\n              fontSize: 11\n            }}\n          />\n        </div>\n        <div className=\"output-wrapper\">\n          <div className=\"actions\">\n            <div className=\"col left\">\n              <button onClick={handleCopy} title=\"Copy\">\n                <i className=\"icon copy\" />\n                {copyText}\n              </button>\n            </div>\n            <div className=\"col right\">\n              <button onClick={handleClearOutput} title=\"Clear\">\n                <i className=\"icon reset\" />\n                {'Clear'}\n              </button>\n            </div>\n          </div>\n          <MonacoEditor\n            language=\"typescript\"\n            theme=\"vs-dark\"\n            value={outputValue}\n            options={{\n              readOnly: true,\n              automaticLayout: true,\n              lineNumbers: 'off',\n              minimap: { enabled: false },\n              fontSize: 10,\n              folding: false\n            }}\n          />\n        </div>\n      </div>\n      <textarea\n        readOnly={true}\n        className=\"no-visible\"\n        ref={textarea => {\n          if (textarea) {\n            textareaRef = textarea\n          }\n        }}\n        value={outputValue}\n      />\n      {isModalOpen && <UploadModal onClose={toggleModal} />}\n    </>\n  )\n}\n","import { ethers } from 'ethers'\n\nimport { getWeb3Instance } from './web3'\nimport { LIB } from '../constants'\nimport { SelectedContracts } from 'components/Playground/types'\n\nexport async function injectGlobals(\n  library: LIB,\n  prevContracts?: SelectedContracts,\n  newContract?: SelectedContracts\n) {\n  switch (library) {\n    case LIB.WEB3: {\n      // @ts-ignore\n      window['web3'] = await getWeb3Instance()\n      break\n    }\n    case LIB.ETHERS: {\n      // @ts-ignore\n      window['ethers'] = ethers\n      // @ts-ignore\n      window['provider'] = new ethers.providers.Web3Provider(window.ethereum)\n      Object.keys(ethers).forEach(k => {\n        // @ts-ignore\n        window[k] = ethers[k]\n      })\n      break\n    }\n    default:\n      break\n  }\n\n  if (prevContracts) {\n    Object.keys(prevContracts)\n      .filter(key => prevContracts[key].instance)\n      .forEach(key => {\n        const contract = prevContracts[key]\n        delete window[contract.name]\n      })\n  }\n\n  if (newContract) {\n    Object.keys(newContract)\n      .filter(key => newContract[key].instance)\n      .forEach(key => {\n        const contract = newContract[key]\n        window[contract.name] = contract.instance\n      })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport { App } from 'components/App'\nimport './index.css'\n\nReactDOM.render(<App />, document.getElementById('root'))\n","import { getNetworkId } from 'libs/web3'\n\nimport { restoreBeforeUnload } from './beforeUnload'\nimport { normalizeIPFSHash } from './ipfs'\nimport { File } from 'components/Files/types'\nimport { LIB } from '../constants'\n\nconst KEY_BASE = 'web3playground-'\nconst KEY_FILES = `${KEY_BASE}files`\nconst KEY_NETWORK = `${KEY_BASE}network`\nconst KEY_LAST_USED = `${KEY_BASE}last-used-`\nconst KEY_CONTRACTS = `${KEY_LAST_USED}contracts`\nconst KEY_CODE = `${KEY_LAST_USED}code`\nconst KEY_LIBRARY = `${KEY_LAST_USED}library`\n\nexport type LastUsedContracts = {\n  name: string\n  address: string\n  isProxy: boolean\n}[]\n\n// Files\nexport function saveFile(file: File) {\n  if (!file.id && !file.name) {\n    console.error('Could not save file')\n    return\n  }\n\n  const saveFiles = getFiles()\n\n  if (saveFiles.map(savedFile => savedFile.id).includes(file.id)) {\n    // Nothing to save\n    return\n  }\n\n  saveFiles.push(file)\n\n  try {\n    window.localStorage.setItem(KEY_FILES, JSON.stringify(saveFiles))\n  } catch (e) {\n    console.warn(e.message)\n  }\n}\n\nexport function getFiles(): File[] {\n  const data = window.localStorage.getItem(KEY_FILES)\n  return data ? JSON.parse(data) : []\n}\n\nexport function removeFile(file: File) {\n  const saveFiles = getFiles()\n\n  const files = saveFiles.filter(savedFile => savedFile.id !== file.id)\n\n  try {\n    window.localStorage.setItem(KEY_FILES, JSON.stringify(files))\n  } catch (e) {\n    console.warn(e.message)\n  }\n}\n\nexport function renameFile(file: File) {\n  const saveFiles = getFiles()\n  for (let i = 0; i < saveFiles.length; i++) {\n    if (saveFiles[i].id === file.id) {\n      saveFiles[i].name = file.name\n      try {\n        window.localStorage.setItem(KEY_FILES, JSON.stringify(saveFiles))\n      } catch (e) {\n        console.warn(e.message)\n      }\n      return\n    }\n  }\n}\n\nexport function getFileFromHash(hash: string) {\n  const files = getFiles()\n  return files.filter(file => file.id === hash)[0] || normalizeIPFSHash(hash)\n}\n\n// Network\nexport function saveLastUsedNetwork(networkId: number) {\n  try {\n    window.localStorage.setItem(KEY_NETWORK, networkId.toString())\n  } catch (e) {\n    console.warn(e.message)\n  }\n}\n\nexport function getLastUsedNetwork(): number {\n  const data = window.localStorage.getItem(KEY_NETWORK)\n  return data ? Number(data) : -1\n}\n\n// Contract\nexport function saveLastUsedContracts(contracts: LastUsedContracts) {\n  try {\n    window.localStorage.setItem(KEY_CONTRACTS, JSON.stringify(contracts))\n  } catch (e) {\n    console.warn(e.message)\n  }\n  const networkId = getNetworkId()\n  if (networkId) {\n    saveLastUsedNetwork(networkId)\n  }\n}\n\nexport function getLastUsedContracts(): LastUsedContracts | null {\n  const data = window.localStorage.getItem(KEY_CONTRACTS)\n  return data ? JSON.parse(data) : {}\n}\n\n// Code\nexport function saveLastUsedCode(code: string) {\n  try {\n    window.localStorage.setItem(KEY_CODE, code)\n    restoreBeforeUnload()\n  } catch (e) {\n    console.warn(e.message)\n  }\n}\n\nexport function getLastUsedCode(): string | null {\n  const data = window.localStorage.getItem(KEY_CODE)\n  return data ? data : null\n}\n\n// Library\nexport function saveLastUsedLibrary(library: LIB) {\n  try {\n    window.localStorage.setItem(KEY_LIBRARY, library)\n    restoreBeforeUnload()\n  } catch (e) {\n    console.warn(e.message)\n  }\n}\n\nexport function getLastUsedLibrary(): LIB {\n  const data = window.localStorage.getItem(KEY_LIBRARY)\n  return data ? (data as LIB) : LIB.WEB3\n}\n","export enum LIB {\n  WEB3 = 'web3',\n  ETHERS = 'ethers'\n}\n"],"sourceRoot":""}